<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Messaging delivery</title><link rel="stylesheet" href="epub.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></meta></head><body id="page"><div style="display:none;"><a id="GBS.0097.01"></a></div><div title="Messaging delivery" class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"></a>Messaging delivery</h1></div></div></div><p>In this next section, we&#39;re <a id="id236" class="indexterm"></a>going to look at ways of getting messages to an Actor. We&#39;re going to cover core messaging patterns, and we&#39;ll also introduce scheduling along the way.</p><p>There are four core Actor <a id="id237" class="indexterm"></a>messaging patterns: tell, ask, forward, and pipe. We have looked at <code class="literal">tell</code> and <code class="literal">ask</code> where the sender is not an Actor. We will introduce all message <a id="id238" class="indexterm"></a>passing concepts here from<a id="GBS.0097.02"></a> the perspective of an Actor sending messages to another Actor:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Ask</strong></span>: Send a <a id="id239" class="indexterm"></a>message to an Actor, and get a <a id="id240" class="indexterm"></a>response back via a future. When the Actor replies, it completes the future. No messages are sent to the sender&#39;s mailbox</li><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Tell</strong></span>: Send <a id="id241" class="indexterm"></a>a message to an Actor. Any <a id="id242" class="indexterm"></a>replies to <code class="literal">sender()</code> are sent back to the sending Actor</li><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Forward</strong></span>: Take a<a id="id243" class="indexterm"></a> message that has been <a id="id244" class="indexterm"></a>received and send it to another Actor.<a id="GBS.0097.03"></a> Any replies to <code class="literal">sender()</code> are delivered back to the sender of the original message</li><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Pipe</strong></span>: This is <a id="id245" class="indexterm"></a>used to send the result of a future <a id="id246" class="indexterm"></a>back to <code class="literal">sender()</code> or another Actor. If using Ask or handling a future, using Pipe is the correct way to reply with the result of the future</li></ul></div><p>We&#39;ll cover these patterns and the basic principles of messages in Akka in the following section.</p><div title="Messages should be immutable" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"></a>Messages should be immutable</h2></div></div></div><p><a id="GBS.0097.04"></a>As mentioned earlier, messages should be<a id="id247" class="indexterm"></a> immutable. Because Akka is built on the JVM, where Java and Scala have mutable types, it&#39;s possible to send mutable messages but you may lose many of the advantages Akka gives in eliminating shared state. By having messages that are mutable, you introduce the risk that a developer may one day start mutating messages in ways that can break the application.<a id="GBS.0097.05"></a> It&#39;s certainly possible to use mutable messages safely by not changing state, but it&#39;s better to use immutable messages to ensure that no errors are introduced in future changes.</p><p>There are two ways in which messages can be mutable—references and types. I saw Jamie Allen present recently and he demonstrated a matrix of mutable references and types in relation to a message like so:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left;"></col><col style="text-align: left;"></col><col style="text-align: left;"></col></colgroup><thead><tr><th style="text-align: left;" valign="bottom">
<p>References</p>
</th><th style="text-align: left;" valign="bottom">
<p><a id="GBS.0098.01"></a>Mutable Type</p>
</th><th style="text-align: left;" valign="bottom">
<p>Immutable Type</p>
</th></tr></thead><tbody><tr><td style="text-align: left;" valign="top">
<p>Mutable Reference</p>
</td><td style="text-align: left;" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/B04006_03_50.jpg" alt="Messages should be immutable"></img></span><span class="inlinemediaobject"><img src="graphics/B04006_03_50.jpg" alt="Messages should be immutable"></img></span></p>
</td><td style="text-align: left;" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_50.jpg" alt="Messages should be immutable"></img></div>
</td></tr><tr><td style="text-align: left;" valign="top">
<p>Immutable Reference</p>
</td><td style="text-align: left;" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_50.jpg" alt="Messages should be immutable"></img></div>
</td><td style="text-align: left;" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_500.jpg" alt="Messages should be immutable"></img></div>
</td></tr></tbody></table></div><p>If both your references and types are mutable, then that&#39;s the worst case scenario. The following<a id="GBS.0098.02"></a> is an example:</p><div class="informalexample"><pre class="programlisting">public class Message{
public StringBuffer mutableBuffer;
public Message(StringBuffer: mutableBuffer){
this.mutableBuffer = mutableBuffer;
}
}
class Message(var mutableBuffer: StringBuffer = new StringBuffer);</pre></div><p>Here, both the objects <a id="id248" class="indexterm"></a>are referenced, and the object&#39;s state can also change, which is the worst case in our grid.</p><p>Variables referenced in the message (for example, fields)<a id="GBS.0098.03"></a> can either be mutable or immutable. In Scala, field members marked <code class="literal">val</code> are immutable references and field members marked <code class="literal">var</code> are mutable&#8212;the reference can be changed to point to a new object/primitive. In Java, members marked with final are immutable references and those without are mutable. All fields in messages should be of the immutable variety. The field members should be passed in via constructor<a id="GBS.0098.04"></a> arguments to be able to fulfill the immutability contract.</p><p>We can demonstrate how the references can change:</p><div class="informalexample"><pre class="programlisting">Messagemessage=newMessage(newStringBuffer(&quot;original&quot;));
message.mutableBuffer=newStringBuffer(&quot;new&quot;);

valmessage=newMessage(newStringBuffer(&quot;original&quot;))
message.mutableBuffer=newStringBuffer(&quot;new&quot;)</pre></div><p>Here we create a new message, and then we change the <code class="literal">StringBuffer</code> reference to point to<a id="GBS.0098.05"></a> a new <code class="literal">StringBuffer</code>. The message is created with <code class="literal">StringBuffer</code>(<code class="literal">original</code>) but is mutated to <code class="literal">StringBuffer</code>(<code class="literal">new</code>). This shows how the message can be changed because of the change in its reference.</p><div class="mediaobject"><img src="graphics/B04006_03_01.jpg" alt="Messages should be immutable"></img><a id="GBS.0099.01"></a></div><p>We want to eliminate the possibility of someone changing the reference in the message, so we need to make the references <code class="literal">val</code>/<code class="literal">final</code>. The following is an example of immutable references in the<a id="id249" class="indexterm"></a> message, improving on our previous example:</p><div class="informalexample"><pre class="programlisting">public class Message {
public final StringBuffer mutableBuffer;
Message(StringBuffer mutableBuffer) {
                this.mutableBuffer = mutableBuffer;
      <a id="GBS.0099.02"></a>  }
	}</pre></div><p>In Scala, if no access modifiers are supplied in the declaration, the field reference will be an immutable <code class="literal">val</code>. In Java, we use the final modifier to make the reference immutable. Now we can&#39;t change the <code class="literal">mutableBuffer</code> reference to point at a new object—we can be sure the message will always point toward the same <code class="literal">StringBuffer</code>. There is still a problem with this though—we can change the <code class="literal">StringBuffer</code><a id="GBS.0099.03"></a> object itself as it is a mutable type. We can append new characters to a reference. If multiple Actors have a reference to that message, then it&#39;s possible that concurrency errors can occur. The following is an example of us changing the <code class="literal">StringBuffer</code>:</p><div class="informalexample"><pre class="programlisting">Message message = new Message(new StringBuffer())
message.mutableBuffer.append(&quot;appended&quot;);
val message = new Message(StringBuffer(&quot;original&quot;))<a id="GBS.0099.04"></a>
message.mutableBuffer.append(&quot;appended&quot;)</pre></div><p>This demonstrates that even though the message&#39;s <code class="literal">mutableBuffer</code> reference is immutable, the <code class="literal">StringBuffer</code> in memory can still be modified as it is a mutable type as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_02.jpg" alt="Messages should be immutable"></img><a id="GBS.0100.01"></a></div><p>For a message to truly be immutable, it needs to have both immutable references and use immutable types. String is an immutable type, so we can make this message immutable by using String instead of <code class="literal">StringBuffer</code>. An example of the ideal immutable message is as follows:</p><div class="informalexample"><pre class="programlisting">public class ImmutableMessage{
    public final String immutableType;
public ImmutableMessage(String immutableType) {
    this.immutableType<a id="GBS.0100.02"></a> = immutableType;
    }
}
class ImmutableMessage(immutableType: String)</pre></div><p>Now we cannot <a id="id250" class="indexterm"></a>change the message in any way—it&#39;s thread safe and can be sent across threads or machines without any risk of that message changing in any way in its life:</p><div class="informalexample"><pre class="programlisting">new ImmutableMessage(&quot;can&#39;t be changed&quot;);</pre></div><p>There is one more improvement we can make&#8212;use a case class instead of a class in Scala. Case classes are preferred<a id="GBS.0100.03"></a> as they give useful members like a default <code class="literal">toString()</code> and <code class="literal">copy()</code> method. They can be serialized for use in Akka remoting as well. In Java, we will often declare our messages as Serializable as well in case we want to send them over the wire:</p><div class="informalexample"><pre class="programlisting">public class ImmutableMessage implements Serializable {
public final String string;
public ImmutableMessage(String string) {
this.string = string;
}
}
case<a id="GBS.0100.04"></a> class ImmutableMessage(String: String)</pre></div><p>Understanding immutability is essential not only in Akka messages but also in safe and concurrent computing in general. Any time data is to be shared between threads, therefore, aim for immutability first. Now that we know how to make immutable messages, we can look at how to compose actors together with various messaging patterns.</p></div><div title="Ask message pattern" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"></a>Ask message pattern</h2></div></div></div><p><a id="GBS.0100.05"></a>The <a id="id251" class="indexterm"></a>Ask pattern <a id="id252" class="indexterm"></a>produces a future that represents the reply from an Actor. This is often used to talk to Actors from plain objects outside of an Actor system. We looked at Ask, we get a future back that represents the response, but it may not be obvious exactly how Akka knows which message fulfills the future.</p><p>When you ask an Actor, Akka actually creates a temporary Actor in the Actor system. The<a id="GBS.0101.01"></a> <code class="literal">sender()</code> reference that the Actor replies to becomes this temporary Actor. When an Actor replies to the message it receives from an ask, this temporary Actor completes the future with the response as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_03.jpg" alt="Ask message pattern"></img><a id="GBS.0101.02"></a></div><p>Akka knows which message fulfills the future because the <code class="literal">sender()</code> reference becomes that temporary Actor&#39;s path. It&#39;s important to know this so we can compose together multiple Actors and ensure we&#39;re replying to the correct place to fulfill any asks.</p><p>Asks always require a timeout be defined and if the ask is not replied to, then the future will fail with the timeout. The <code class="literal">ask/?</code> method requires<a id="GBS.0101.03"></a> a timeout to be supplied to it&#8212;either a long one in milliseconds or an <code class="literal">akka.util.Timeout</code>, which offers some more expressive descriptions of time.</p><p>In Java, you can Ask with a <code class="literal">Timeout</code> constructed with a <code class="literal">TimeUnit</code> like the following:</p><div class="informalexample"><pre class="programlisting">static import akka.pattern.Patterns.ask; Timeout timeout = new akka.util.Timeout(1,
java.util.concurrent.TimeUnit.SECONDS);
Future future = ask(actor, message, timeout);</pre></div><p><a id="GBS.0101.04"></a>In Scala, you can use <code class="literal">scala.concurrent.duration</code> for defining a timeout with the attractive scala duration<a id="id253" class="indexterm"></a> <span class="strong"><strong>Domain Specific Languages</strong></span>(<span class="strong"><strong>DSL</strong></span>), which <a id="id254" class="indexterm"></a>lets you describe a duration as, for example, 1 second. In Scala, the timeout supplied to the ask is implicit, which helps to simplify the ask semantics to a concise statement:</p><div class="informalexample"><pre class="programlisting">actorRef ? message</pre></div><p>For example, with the timeout and imports, your code would<a id="GBS.0102.01"></a> look like the following:</p><div class="informalexample"><pre class="programlisting">import scala.concurrent.duration._
import akka.pattern.ask
implicit val timeout = akka.util.Timeout(1 second)
val future = actorRef ? &quot;message&quot;</pre></div><p>We&#39;ll look at an <a id="id255" class="indexterm"></a>example of a design using ask to demonstrate how we can compose together asks. Because Ask gives Futures, this is essentially composing together Futures that the Actors produce with Ask.</p><div title="Designing with Ask" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec32"></a>Designing with Ask</h3></div></div></div><p>We&#39;ll<a id="GBS.0102.02"></a> demonstrate our <a id="id256" class="indexterm"></a>example application <a id="id257" class="indexterm"></a>design using the Ask pattern first. This is the most naive approach. The example we&#39;ll show here is for the article parse service using ask that will check the cache, and, if the parsed article is not in the cache, it will ask an <code class="literal">HttpClientActor </code>and then have the result parsed by an <code class="literal">ArtcileParserActor</code>. After retrieving the results, it will attempt to cache the<a id="GBS.0102.03"></a> article and then return the article to the user as shown the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_04.jpg" alt="Designing with Ask"></img><a id="GBS.0102.04"></a></div><p>This is a useful <a id="id258" class="indexterm"></a>example to look<a id="id259" class="indexterm"></a> at but it&#39;s not an optimal design. This is very much how we would have done this using a synchronous API, so it&#39;s a good starting point to build on. We&#39;ll examine some code before proceeding.</p><p>For brevity, we&#39;ll omit the Actor code except for the service Actor. The full code examples are in the GitHub examples in the folder in this chapter. For the context of reading<a id="GBS.0103.01"></a> the code, each of the Actors sends back either a failure or a success&#8212;a String representing the article (raw or parsed).</p><p>The following is the Scala source:</p><div class="informalexample"><pre class="programlisting">packagecom.akkademy.askdemo
class AskDemoArticleParser(cacheActorPath: String, httpClientActorPath: String, acticleParserActorPath: String,implicit val timeout: Timeout
) 
extends Actor {
  val cacheActor = context.actorSelection(cacheActorPath)<a id="GBS.0103.02"></a>
  val httpClientActor = context.actorSelection(httpClientActorPath)
  val articleParserActor = context.actorSelection(acticleParserActorpath)
  import scala.concurrent.ExecutionContext.Implicits.global

  override def receive: Receive = {
    case ParseArticle(uri) =&gt;
      val senderRef = sender() //sender ref needed for closure

      val cacheResult = cacheActor ? GetRequest(uri) //ask cache<a id="GBS.0103.03"></a> actor

      val result = cacheResult.recoverWith { //if request fails, then ask the articleParseActor
        case _: Exception =&gt;
          val fRawResult = httpClientActor ? uri

          fRawResult flatMap {
            case HttpResponse(rawArticle) =&gt;
              articleParserActor ? ParseHtmlArticle(uri, rawArticle)
            case x =&gt;
              Future.failed(new Exception(&quot;unknown<a id="GBS.0103.04"></a> response&quot;))
          }
      }
                 
      result onComplete { //could use Pipe (covered later)
        case scala.util.Success(x: String) =&gt;
          println(&quot;cached result!&quot;)
          senderRef ! x //cached result
        case scala.util.Success(x: ArticleBody) =&gt;
          cacheActor ! SetRequest(uri, x.body)
          senderRef ! x
        case scala.util.Failure(t) =&gt;
    <a id="GBS.0103.05"></a>      senderRef ! akka.actor.Status.Failure(t)
        case x =&gt;
          println(&quot;unknown message! &quot; + x)
      }
  }
}</pre></div><p>The following<a id="id260" class="indexterm"></a> is the equivalent Java8 <a id="id261" class="indexterm"></a>code:</p><div class="informalexample"><pre class="programlisting">public class AskDemoArticleParser extends AbstractActor {

    private final ActorSelection cacheActor;
    private final ActorSelection httpClientActor;
    private final ActorSelection artcileParseActor;
    private final Timeout<a id="GBS.0104.01"></a> timeout;

    public AskDemoArticleParser(String cacheActorPath, String httpClientActorPath, String artcileParseActorPath, Timeout timeout) {
        this.cacheActor = context().actorSelection(cacheActorPath);
        this.httpClientActor = context().actorSelection(httpClientActorPath);
        this.artcileParseActor = context().actorSelection(artcileParseActorPath);
        this.timeout = timeout;<a id="GBS.0104.02"></a>
    }

public PartialFunction receive() {
        return ReceiveBuilder.
                match(ParseArticle.class, msg -&gt; {
                    final CompletionStage cacheResult = toJava(ask(cacheActor, new GetRequest(msg.url), timeout));
                    final CompletionStage result = cacheResult.handle((x, t) -&gt; {
                        return (x != null)
                                ?<a id="GBS.0104.03"></a> CompletableFuture.completedFuture(x)
                                : toJava(ask(httpClientActor, msg.url, timeout)).
                                thenCompose(rawArticle -&gt; toJava(
                                                ask(artcileParseActor,
                                                        new ParseHtmlArticle(msg.url,
                                                        <a id="GBS.0104.04"></a>        ((HttpResponse) rawArticle).body), timeout))
                                );
                    }).thenCompose(x -&gt; x);

                    final ActorRef senderRef = sender();
                    result.handle((x,t) -&gt; {
                        if(x != null){
                            if(x instanceof ArticleBody){
                                String body = ((ArticleBody) x).body;<a id="GBS.0104.05"></a> //parsed article
                                cacheActor.tell(body, self()); //cache it
                                senderRef.tell(body, self()); //reply
                            } else if(x instanceof String) //cached article
                                senderRef.tell(x, self());
                        } else if( x == null )
                            senderRef.tell(new akka.actor.Status.Failure((T<a id="GBS.0105.01"></a>hrowable)t), self());
                        return null;
                    });

                }).build();
    }
}</pre></div><p>Both the Scala and<a id="id262" class="indexterm"></a> Java8 examples have <a id="id263" class="indexterm"></a>the same functionality—the Actor constructor takes strings with the Actor paths and looks up each of the Actors with <code class="literal">actorSelection</code> as we have done previously. Injecting the paths are dependencies. This lets us configure where our actors<a id="GBS.0105.02"></a> are. For example, the cached <code class="literal">b</code> would be local in test and on a remote machine in production.</p><p>Once we receive a message, we try to get a cached article. If the <code class="literal">cacheResult</code> misses or fails for any reason, we compose together two more asks in a recover/exceptionally block:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Ask the HTTP client Actor for the raw article</li><li style="list-style-type: disc;" class="listitem">Ask the article parser to parse the raw article from the HTTP Actor</li></ul></div><p>If the cache<a id="GBS.0105.03"></a> request fails, we don&#39;t care what the issue is with the cache result&#8212;we can still give the user a result if the cache is offline for example. We would, however, log the unexpected error or capture the cause of the error in a metric.</p><p>Finally, we register what to do when we have the result or error at the end of processing&#8212;we either send back the success or send a failure with the cause of the error.</p><p><a id="GBS.0105.04"></a>The use of ask is a simple solution, but there are a few &quot;gotchas&quot; and issues to look out for when using ask as the primary message patterns in Actors. Ask is a good place to start with for building simple solutions, but it can sometimes be better to design with tell as we&#39;ll look at shortly. Let&#39;s look at a few of the elements of using ask that we need to be aware of.</p></div><div title="Callbacks execute in another execution context" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec33"></a>Callbacks execute in another<a id="GBS.0105.05"></a> execution context</h3></div></div></div><p>Note that in the <a id="id264" class="indexterm"></a>preceding example, a local <code class="literal">ActorRef </code>variable is created to store the <code class="literal">sender()</code>method&#39;s result. This is very important: this is necessary here and you will no doubt bump into this at least once when you start working with Akka. Because the lambdas are executed somewhere else, in another execution context on another thread, the <code class="literal">sender()</code>method will return an unexpected<a id="GBS.0106.01"></a> value when the code block in the lambda is running. This is a non-obvious issue to beginners. In older Scala Akka examples, <code class="literal">sender()</code> was often written without the brackets. It&#39;s recommended that <code class="literal">sender()</code>always be expressed with the brackets in Scala as it does not have referential transparency (it doesn&#39;t return the same value every time it&#39;s called)&#8212; it&#39;s clearer that this is a method call when<a id="GBS.0106.02"></a> you add the brackets. In order for the correct <code class="literal">ActorRef</code> to be referred to, <code class="literal">sender()</code>must be called in the main thread and the reference stored into a variable. That variable will correctly be passed into the lambda&#39;s closure when it is executed. There is a better way to handle the reply called Pipe, which we&#39;ll look at shortly, but this is an<a id="id265" class="indexterm"></a> important quality of closures to understand.</p></div><div title="Timeouts are required" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec34"></a>Timeouts<a id="GBS.0106.03"></a> are required</h3></div></div></div><p>Note that the example<a id="id266" class="indexterm"></a> uses a single timeout and passes it to several asks. You cannot ask an Actor for a reply without creating a bounded timeout. If the Actor that is asked does not reply to the future before the timeout ends, the future will be failed.</p><p>Selecting the correct timeout value can be difficult without real data from production systems under load. Setting the timeout<a id="GBS.0106.04"></a> too low will cause failures to be reported for operations that would have succeeded. Setting the timeout too high will force users to wait too long when operations might have failed due to anomalies. To set timeouts, you&#39;ll want to have statistics on the operations in production. You can&#39;t control the performance of systems you depend on, so it can be difficult to get this correct.</p><p>Because every<a id="GBS.0106.05"></a> ask requires a timeout, if Actors are asking Actors that are asking Actors, it&#39;s not easy to enforce a single timeout. If an error occurs at some point, it&#39;s possible you&#39;ll see several timeouts in your logs, which can make debugging quite difficult as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_05.jpg" alt="Timeouts are required"></img><a id="GBS.0107.01"></a></div><p>In the preceding image, it&#39;s possible that the 2-second timeout causes the future to fail, even if all of the code is working correctly and all systems are responding.</p><p>It may seem like a good idea to place a large timeout to avoid errors from occurring. Placing arbitrary and large timeouts should be considered an anti-pattern as it violates the responsive tenet of <a id="id267" class="indexterm"></a>reactive design we try to adhere<a id="GBS.0107.02"></a> to when building our applications. A 30-second timeout offers very little value in reality as a user waiting for data has likely given up by the time the timeout has occurred. In most use cases, if your users legitimately need to wait for more than 10 seconds for an operation, it&#39;s possible your users won&#39;t be using your software for long. Obviously, there are exceptions, but studies from Microsoft<a id="GBS.0107.03"></a> and Google have shown that user behavior is impacted negatively if they have to wait for more than 2 seconds for a page to appear in web applications.</p></div><div title="Timeout stacktraces aren&#39;t useful" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec35"></a>Timeout stacktraces aren&#39;t useful</h3></div></div></div><p>Each ask you use has a<a id="id268" class="indexterm"></a> timeout. In our example, the operation spans multiple asks, so there are multiple places where timeouts can occur. The ask timeouts will throw exceptions from Akka&#39;s scheduler thread rather<a id="GBS.0107.04"></a> than a thread local to the Actor, so you won&#39;t be able to tell from printing the <code class="literal">AskTimeoutExceptions</code> stacktrace specifically which ask operation timed out. It can be difficult to debug an application when all you have is an exception like the following:</p><div class="informalexample"><pre class="programlisting">akka.pattern.AskTimeoutException: Ask timed out on [Actor[akka://system/user/actor#778114812]] after [2000 ms]
        at akka.pattern.PromiseActorRef$$anonfun$<a id="GBS.0107.05"></a>1.apply$mcV$sp(AskSupport.scala:335)
        at akka.actor.Scheduler$$anon$7.run(Scheduler.scala:117)</pre></div><p>One more thing to watch out for is if your actor throws an unexpected exception and doesn&#39;t reply with the failure. It may appear that the error occurred due to the timeout, but the cause might be elsewhere.</p><p>The lesson here is that when using ask, you should always reply to messages with failures<a id="GBS.0108.01"></a> when errors are encountered in your code. If an Actor throws an exception, the Actor will not reply with a message. In an Actor, you&#39;re responsible for implementing all message handling behavior&#8212;if an actor expects a reply, Akka will not implicitly handle any replies for you&#8212;you must always reply to messages yourself when a reply is expected.</p><p>Ask is a pattern built on top of Akka&#8212;it&#39;s a useful<a id="GBS.0108.02"></a> helper, but there is no mechanism in Akka to automatically reply to messages or fail Futures generated by the Ask pattern. The Ask pattern creates a Scala Promise and a temporary (extra) Actor to receive a reply that it uses to fulfill the Promise. There is no mechanism to make the temporary Actor aware of an exception encountered in another Actor, so if you don&#39;t reply to the temporary Actor the<a id="GBS.0108.03"></a> Ask creates, it will not fulfill the Promise, and the timeout will fail the corresponding Future as in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_06.jpg" alt="Timeout stacktraces aren&#39;t useful"></img><a id="GBS.0109.01"></a></div></div><div title="Ask has overhead" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec36"></a>Ask has overhead</h3></div></div></div><p>The ask pattern may seem simple<a id="id269" class="indexterm"></a> but it has some <code class="literal">hidden</code> overhead. First, Ask causes Akka to create a new temporary Actor in the<code class="literal">/temp</code> path. That Actor awaits the response from the Actor that receives the Ask message. Next, there is also the overhead of the future. Ask creates a future that the temporary Actor completes. It&#39;s not a huge overhead, but it is worth considering if<a id="GBS.0109.02"></a> your ask operations occur with extremely high frequency. Ask can be simpler, but there are more efficient solutions using only tell where performance matters.</p></div><div title="Complexity of Actors and Ask" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec37"></a>Complexity of Actors and Ask</h3></div></div></div><p>If you&#39;re simply asking your<a id="id270" class="indexterm"></a> Actors, and they don&#39;t contain state, then you may be better off using Futures alone. In the preceding examples Actors are used as an asynchronous API by invoking them with ask.<a id="GBS.0109.03"></a> We could replace the Actors with methods that give back Futures and our code would be equivalent and simpler to read.</p><p>For quite a while, I was of the opinion that it&#39;s better to not use Actors if you don&#39;t have either:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">State and concurrency; or</li><li style="list-style-type: disc;" class="listitem">Distribution</li></ul></div><p>If you aren&#39;t using Akka for remoting or you aren&#39;t using Akka for concurrent access to state by encapsulating state in Actors, then it may<a id="GBS.0109.04"></a> not be obvious what the benefits are compared to stateless classes that are asynchronous and non-blocking.</p><p>However, I believe this<a id="id271" class="indexterm"></a> is because I was writing Actor code with poor designs. It is true that if you have no state, an asynchronous API is simpler than using Ask with Actors. However, if you are designing with the &quot;Tell Don&#39;t Ask&quot; principle, then you can have code that is simpler, better<a id="GBS.0109.05"></a> performing, and can be easier to debug when using Actors. We&#39;ll look at tell next.</p></div></div><div title="Tell" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"></a>Tell</h2></div></div></div><p>Tell<a id="id272" class="indexterm"></a> is the simplest messaging pattern—however, it can take some time to learn<a id="id273" class="indexterm"></a> how to use it best, which is why it is being presented here after Ask. It is often viewed as a &quot;fire and forget&quot; message delivery mechanism as no sender is specified; however, request/reply style messaging can be completed with<a id="GBS.0110.01"></a> tell when a little ingenuity is applied.</p><div class="mediaobject"><img src="graphics/B04006_03_07.jpg" alt="Tell"></img><a id="GBS.0110.02"></a></div><p>Tell is a method of the <code class="literal">ActorRef</code>/<code class="literal">ActorSelection </code>classes. It can take a reply to as an argument as well which becomes <code class="literal">sender()</code>in the Actor that receives the Message. By default, in Scala, the sender is implicitly defined as the Actor that sent the message. If there is no sender—for example, invoking ask from outside of an Actor—then the response address default is no mailbox (called <code class="literal">DeadLetters</code>).</p><p><a id="GBS.0110.03"></a>In Java, there are no implicits or default values, so you have to supply the sender. If you don&#39;t want to supply any specific sender to reply to, you should use the following convention:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Use <code class="literal">self()</code> if sending from an actor:<div class="informalexample"><pre class="programlisting">actor.tell(message, self());</pre></div></li><li style="list-style-type: disc;" class="listitem">Use <code class="literal">noSender</code> if sending from outside of the actor system:<div class="informalexample"><pre class="programlisting">actor.tell(&quot;message&quot;, akka.actor.ActorRef.noSender());</pre></div></li><li style="list-style-type: disc;" class="listitem">As covered in Scala, this is all<a id="GBS.0110.04"></a> default/implicit, so you get this for free implicitly with the simple syntax:<div class="informalexample"><pre class="programlisting">actor ! &quot;message&quot;</pre></div></li></ul></div><p>This is the <a id="id274" class="indexterm"></a>expected behavior with tell—the reply reference should <a id="id275" class="indexterm"></a>be the Actor sending the message or it should be none if it&#39;s not an Actor sending the message. However, using a different sender can be quite important when using tell&#8212;we can actually eliminate asks through some creative use of reply<a id="GBS.0111.01"></a> addresses and storing state in Actors, as we&#39;ll see soon:</p><div title="Designing with Tell" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec38"></a>Designing with Tell</h3></div></div></div><p>It may seem odd to have<a id="id276" class="indexterm"></a> put ask before tell, as, theoretically, tell is a much simpler message delivery mechanism. In building applications, it may seem natural to ask several Actors and compose the Futures similar to what we did in the ask design example. We covered several of the problems with ask, as well as the<a id="GBS.0111.02"></a> timeouts and overhead associated with it, so there is motivation to look at other solutions. We can do better by using tell.</p><p>Tell is often viewed as a fire-and-forget messaging pattern, but when designing, changing how you think about objects and actors and how they interact can yield better designs. If you&#39;re coming from Scala, you might find your designs become simpler if you store a bit of<a id="GBS.0111.03"></a> state in Actors and if you create some temporary Actors to handle certain tasks. This is counter-intuitive for the functional programmer who avoids state. Object-oriented languages were originally message-driven and so we can get a few hints about the lessons learned in design by reviewing some of the good practices from <code class="literal">SmallTalk</code> culture.</p><div title="Handling replies with Tell" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec23"></a>Handling replies with Tell </h4></div></div></div><p>Because the sender reference<a id="GBS.0111.04"></a> is available to send back a message, it&#39;s easy to reply to a message. However, to handle a reply, we need to have the ability to recall which message the Actor is replying to. If we store some state in the Actor about messages that it expects a response to, then we can effectively &quot;ask&quot; an Actor without the pitfalls of ask described earlier.</p><p>For a very simple example of designing with tell, we<a id="GBS.0111.05"></a> can store some context in an Actor with a map with a key and send the key in the message. Then, when a message comes back with that key, we can restore that context and complete handling the message. This allows us to use semantics similar to ask without the overhead of ask.</p><div class="mediaobject"><img src="graphics/B04006_03_08.jpg" alt="Handling replies with Tell"></img><a id="GBS.0112.01"></a></div><p>This may seem like a lot of <a id="id277" class="indexterm"></a>overhead when you can use ask, but if you&#39;re trying to compose together many Actors, it removes the timeouts and extra Actor creation that ask incurs. This lets us control where the timeout occurs.</p><p>Because there is no timeout with tell, we generally want to produce our own timeout at some point in time.</p></div><div title="Scheduling a Tell Timeout" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec24"></a>Scheduling a Tell Timeout</h4></div></div></div><p>We&#39;ll introduce the scheduler here<a id="GBS.0112.02"></a> as a minor element. The scheduler is capable of repeating messages at an interval; however, it is most commonly used as a way of deferring a tell. For example, if an Actor wants to send itself a &quot;check-for-timeout&quot; message after 3 seconds, the scheduler is the mechanism that can be used to accomplish that.</p><p>Very often in our Actors, we expect some event to occur before a certain period of time<a id="GBS.0112.03"></a> elapses, and if that event has not occurred, then we want to fail in some manner. The scheduler can be used to schedule such an event (for example, a timeout). The following is an example of sending an Actor a timeout message after 3 seconds:</p><div class="informalexample"><pre class="programlisting">//Java
context().system().scheduler().scheduleOnce(Duration.create(3, TimeUnit.SECONDS), actor, &quot;timeout&quot;);

//Scala
context.system.scheduler.scheduleOnce(3<a id="GBS.0112.04"></a> seconds, actor, &quot;timeout&quot;)</pre></div><p>We&#39;ll see how this comes into play shortly.</p><p>Tell Don&#39;t Ask–<span class="emphasis"><em>Procedural code gets information then makes decisions. Object-oriented code tells objects to do things</em></span>—Alec Sharp, SmallTalk by Example.</p><p>The OO designers who worked in <code class="literal">SmallTalk</code> delivered a very important principle in Object-oriented design, which translates quite well into the Actor paradigm—Tell, Don&#39;t Ask.</p><p><a id="GBS.0112.05"></a>This is saying that<a id="id278" class="indexterm"></a> messages should be commands and that your Actors should be combinations of state and behavior instead of invocations of procedures&#8212;just like good object-oriented design. When you&#39;re designing, I&#39;d recommend you take that a step farther and consider avoiding ask between Actors to see what your designs look like. This is a heuristic, so evaluate your designs, and the costs and<a id="GBS.0113.01"></a> benefits. You&#39;ll often find tell will produce simpler, leaner flows.</p><p>Tell Don&#39;t Ask is actually more of an object-oriented design heuristic, but given some of the pitfalls of the ask pattern covered, we may want consider this rule of thumb in designing with Actors as well. Ask can be simple, so evaluate it when working with Akka, but be aware of the alternative solutions as well.</p></div><div title="Avoiding Ask with an Anonymous Actor" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec25"></a>Avoiding Ask<a id="GBS.0113.02"></a> with an Anonymous Actor</h4></div></div></div><p>If you&#39;re invoking tell from outside of an Actor in plain objects, there is no immediately obvious way to receive and handle a response apart from ask. As we&#39;ve looked at, between Actors, you can handle a response by capturing some state specific to the current message in an Actor (for example, an ID). There is another option for handling a reply as well&#8212;by using a new<a id="GBS.0113.03"></a> temporary Actor, we can describe the response to a single message.</p><p>We&#39;ll cover using tell instead of ask in an example. In this example, we&#39;ll create a temporary Actor to handle the response to a message. Note that this is very similar to how Akka handles ask under the hood—it creates a temporary Actor to handle the response sent to the sender to complete the future.</p><p>We&#39;ll demonstrate the receive<a id="GBS.0113.04"></a> block only (Java and then Scala):</p><div class="informalexample"><pre class="programlisting">//Java
public PartialFunction receive() {
        return ReceiveBuilder.
                match(ParseArticle.class, msg -&gt; {
                    ActorRef extraActor = buildExtraActor(sender(), msg.url);
                    cacheActor.tell(new GetRequest(msg.url), extraActor);
                    httpClientActor.tell(msg.url, extraActor);
                    context().system().sch<a id="GBS.0113.05"></a>eduler().scheduleOnce(timeout.duration(),
                            extraActor, &quot;timeout&quot;, context().system().dispatcher(), ActorRef.noSender());
                }).build();
    }

//Scala
  override def receive: Receive = {
    case msg @ ParseArticle(uri) =&gt;

      val extraActor = buildExtraActor(sender(), uri)

      cacheActor.tell(GetRequest(uri), extraActor)
      httpClientActor.tell(&quot;te<a id="GBS.0114.01"></a>st&quot;, extraActor)

      context.system.scheduler.scheduleOnce(timeout.duration, extraActor, &quot;timeout&quot;)
  }</pre></div><p>This looks a bit simpler because we&#39;re not composing any Futures, but there is an extra actor that is created in the <code class="literal">buildExtraActor</code> method.</p><p>We&#39;ll demonstrate<a id="id279" class="indexterm"></a> the <code class="literal">buildExtraActor</code> method in a moment, but we&#39;ll walk through this first. The block gets the <code class="literal">ParseArticle</code> message and begins by creating<a id="GBS.0114.02"></a> the <code class="literal">extraActor</code>. The term extra is a term attributed to Jamie Allen in his book <span class="emphasis"><em>Effective Akka</em></span> from <span class="emphasis"><em>O&#39;Reilly</em></span> publications where he demonstrates a similar pattern which he refers to as the Extra Pattern.</p><p>After creating the <code class="literal">extraActor</code>, the receive block continues to send three messages:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Send a message to the cache actor requesting the cached article that causes a String to be sent back to the sender.<a id="GBS.0114.03"></a> Here, sender is supplied to the tell as the <code class="literal">extraActor</code></li><li style="list-style-type: disc;" class="listitem">Send a message to the <code class="literal">httpClientActor</code> requesting the raw article that causes an <code class="literal">HttpResponse </code>to be sent to the <code class="literal">extraActor</code></li><li style="list-style-type: disc;" class="listitem">Schedule a <code class="literal">timeout</code> message to be sent to the <code class="literal">extraActor</code></li></ul></div><p>This is different than the ask example because we don&#39;t wait for the cache to respond in this particular example. It&#39;s possible to compose the requests in the extra<a id="GBS.0114.04"></a> Actor&#39;s behavior, but for simplicity, here we&#39;ll send them both off and have the extra Actor respond to whichever message is received first.</p><p>The <code class="literal">extraActor</code> is an anonymous Actor that describes the response to the three possible messages above:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">If it gets a response from the cache, respond with that to the <code class="literal">originalSender</code></li><li style="list-style-type: disc;" class="listitem">If it gets an HTTP response, send that to the <code class="literal">ArticleParser </code>to parse and have<a id="GBS.0114.05"></a> the article parser reply back with the <code class="literal">ArticleBody</code></li><li style="list-style-type: disc;" class="listitem">If it gets an <code class="literal">ArticleBody</code>, the <code class="literal">HttpResponse </code>has been parsed, so we want to cache the result and reply to the <code class="literal">originalSender</code></li><li style="list-style-type: disc;" class="listitem">If it gets a timeout, send a failure back to the <code class="literal">originalSender</code></li></ul></div><p>The <code class="literal">extraActor</code> describes the response to the three messages, including how to get the raw HTML article and then how to parse it. By putting all of this behavior<a id="GBS.0115.01"></a> into a single anonymous Actor, which can only handle one of each type of the messages, we can describe the response <a id="id280" class="indexterm"></a>to the behavior in each case.</p><div class="mediaobject"><img src="graphics/B04006_03_09.jpg" alt="Avoiding Ask with an Anonymous Actor"></img><a id="GBS.0115.02"></a></div><p>Here is the code for the factory method for the extra Actor:</p><div class="informalexample"><pre class="programlisting">//Java
private ActorRef buildExtraActor(ActorRef senderRef, String uri){

        class MyActor extends AbstractActor {
            public MyActor() {
            receive(ReceiveBuilder
                        .matchEquals(String.class, x -&gt; x.equals(&quot;timeout&quot;), x -&gt; { //if we get timeout, then fail
                            senderRef.tell(new<a id="GBS.0115.03"></a> Status.Failure(new TimeoutException(&quot;timeout!&quot;)), self());
                            context().stop(self());
                        })
                        .match(HttpResponse.class, httpResponse -&gt; { //If we get the cache response first, then we handle it and shut down.
                            //The cache response will come back before the HTTP response so we never parse in<a id="GBS.0115.04"></a> this case.
                            artcileParseActor.tell(new ParseHtmlArticle(uri, httpResponse.body), self());
                        })
                        .match(String.class, body -&gt; { //If we get the cache response first, then we handle it and shut down.
                            //The cache response will come back before the HTTP response so we never parse in this case.
       <a id="GBS.0116.01"></a>                     senderRef.tell(body, self());
                            context().stop(self());
                        })
                        .match(ArticleBody.class, articleBody -&gt; {//If we get the parsed article back, then we&#39;ve just parsed it
                            cacheActor.tell(new SetRequest(articleBody.uri, articleBody.body), self());
                            senderRef.tell(articleBody.bo<a id="GBS.0116.02"></a>dy, self());
                            context().stop(self());
                        })
                        .matchAny(t -&gt; { //We can get a cache miss
                            System.out.println(&quot;ignoring msg: &quot; + t.getClass());
                        })
                        .build());
            }
        }

        return context().actorOf(Props.create(MyActor.class,<a id="GBS.0116.03"></a> () -&gt; new MyActor()));
    }

//Scala
  private def buildExtraActor(senderRef: ActorRef, uri: String): ActorRef = {
    return context.actorOf(Props(new Actor{
      override def receive = {
        case &quot;timeout&quot; =&gt; //if we get timeout, then fail
          senderRef ! Failure(new TimeoutException(&quot;timeout!&quot;))
          context.stop(self)

        case HttpResponse(body) =&gt; //If we get the<a id="GBS.0116.04"></a> http response first, we pass it to be parsed.
          articleParserActor ! ParseHtmlArticle(uri, body)

        case body: String =&gt; //If we get the cache response first, then we handle it and shut down.
          //The cache response will come back before the HTTP response so we never parse in this case.
          senderRef ! body
          context.stop(self)

        case ArticleBody(uri, body)<a id="GBS.0116.05"></a> =&gt; //If we get the parsed article back, then we&#39;ve just parsed it
          cacheActor ! SetRequest(uri, body) //Cache it as we just parsed it
          senderRef ! body
          context.stop(self)

        case t =&gt; //We can get a cache miss
          println(&quot;ignoring msg: &quot; + t.getClass)
      }
    }))
  }</pre></div><p>Note that there are <a id="id281" class="indexterm"></a>three possible outcomes:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">The cache responds with the body</li><li style="list-style-type: disc;" class="listitem">The http<a id="GBS.0117.01"></a> article comes back, is parsed and then cached</li><li style="list-style-type: disc;" class="listitem">Neither of these events occur before the timeout message</li></ul></div><p>All three of these outcomes cause the <code class="literal">extraActor</code> to be stopped by executing <code class="literal">context().stop(self());</code> this Actor is short lived, then—it will not live more than 3 seconds.</p><p>There is the case where the cache fails and the article comes back&#8212;this is a special case because we need to parse the article<a id="GBS.0117.02"></a> still, so we send this message to the article parser and then handle the response.</p><p>This looks like a bit more code, and it is, but it&#39;s actually lighter than the ask example believe it or not:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">The ask example causes a future to be created for each ask</li><li style="list-style-type: disc;" class="listitem">The ask example causes a temporary Actor to be created for each ask</li></ul></div><p>Our example has no Futures and only one extra Actor. It&#39;s also simpler to analyze<a id="GBS.0117.03"></a> errors:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">The ask example has three separate timeouts that can fail</li></ul></div><p>Our example has only one timeout which we control - the timeout is either encountered or else the success case occurs. In this approach, we can also log any state in the temporary Actor when the timeout is encountered to understand exactly what occurred. Future timeouts are not very helpful in comparison.</p><p>At the expense of a bit<a id="GBS.0117.04"></a> more code than the ask example, we&#39;re taking control over the behavior instead of relying on Akka&#39;s ask implementation details, and in turn, we&#39;re able to construct the solution to fit the exact use case. I&#39;ve worked in teams that prefer simple terse code so which solution you choose &#8211; tell or ask &#8211; will be up to you and your team to decide. Explore both and understand their pros and cons. For any<a id="GBS.0117.05"></a> performance critical areas of your code, tell can be more performant.</p><p>A good exercise here would be to change the extra Actor code only request or only parse the article if the cache request fails to return a result. Don&#39;t be afraid to keep state in the extra Actor to understand where it is in its lifecycle.</p><p>This demonstrates<a id="id282" class="indexterm"></a> how a design can be changed from composing asks to a design that avoids<a id="GBS.0118.01"></a> ask completely by using an extra Actor to deal with responses and control the flow of messages between Actors. There are no panaceas, but you should try to evaluate a few different designs when building and see which works best in your use case.</p></div></div><div title="Forward" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec39"></a>Forward</h3></div></div></div><p>While tell semantically<a id="id283" class="indexterm"></a> sends a message to another Actor with the reply <a id="id284" class="indexterm"></a>address being the current Actor, forward is much like the case in<a id="GBS.0118.02"></a> forwarding mail&#8212;the original sender stays the same but there is a new recipient.</p><p>Where tell lets you specify the reply address and it is implicit that the Actor that sends the message, forward delivers a message with the reply address equal to sender.</p><div class="mediaobject"><img src="graphics/B04006_03_10.jpg" alt="Forward"></img><a id="GBS.0118.03"></a></div><p>This is useful where a message received will be delegated to another actor to fulfill, and the product of that Actor is needed by the original requester.</p><p>The intermediate Actor hands off the message, or possibly a new one, but the original sender is passed with the new message. An example use case could be getting a history from a bank account. There may be one History Actor who then delegates<a id="GBS.0118.04"></a> the request for account history to either a <code class="literal">ChequingAccount </code>or <code class="literal">CreditCardAccount </code>Actor. The message requesting the account history would be forwarded to the more specific Actor to complete.</p><p>There is nothing special about forward, and you can accomplish the same thing with <code class="literal">ActorRef.tell</code> (message, sender) by supplying the sender. It is semantically clearer to use forward where it makes sense (especially<a id="GBS.0119.01"></a> in Scala where the <code class="literal">!</code> method is generally used):</p><div class="informalexample"><pre class="programlisting">//Java
actor.forward(result, getContext());

//Scala
actor forward message</pre></div><p>Note that the <a id="id285" class="indexterm"></a>context<a id="id286" class="indexterm"></a> is implicit in Scala.</p></div><div title="Pipe" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec40"></a>Pipe</h3></div></div></div><p>Very often you will <a id="id287" class="indexterm"></a>have a future in your Actor that you want to send <a id="id288" class="indexterm"></a>back to the sender. We&#39;ve covered that <code class="literal">sender()</code> is a method, so you have to store a reference to sender when using callbacks in Futures:</p><div class="informalexample"><pre class="programlisting">//Java
final ActorRef<a id="GBS.0119.02"></a> senderRef = sender();
future.map(x -&gt; {senderRef.tell(x, ActorRef.noSender()}));

//Scala
val senderRef = sender();
future.map(x =&gt; senderRef ! ActorRef.noSender);</pre></div><p>Callbacks registered on a future, such as map in this example, will execute in another thread, so they don&#39;t have access to the correct value from <code class="literal">sender()</code>. It&#39;s very unclear why the sender is stored and it is hard to understand code<a id="GBS.0119.03"></a> like this. It likely won&#39;t make sense to anyone who hasn&#39;t encountered this issue on their own. Quite possibly, as you read this, you may wonder why you don&#39;t just call <code class="literal">sender()</code> in the lambda. Try it out and you&#39;ll see unexpected results as <code class="literal">sender()</code> returns something different when it&#39;s called from the lambda.</p><p>We can skirt around this entire confusing mess by using the Pipe pattern. Pipe will<a id="GBS.0119.04"></a> take the result of a future and reply to the sender with the result of the future, whether success or failure, which is exactly what we want:</p><div class="informalexample"><pre class="programlisting">//Java
pipe(future, system.dispatcher()).to(sender());

//Scala
future pipeTo sender()
pipe(future) to sender()</pre></div><p>Again, pipe takes the result of the future and pipes it to the Actor <code class="literal">ref</code> provided. In these examples, we show <code class="literal">sender(),</code> and because <code class="literal">sender()</code> is<a id="GBS.0119.05"></a> executed on the current thread, it all behaves as expected without doing anything strange like storing a reference in a variable. Much better!</p><p>If this is at all unclear, trust <a id="id289" class="indexterm"></a>me you will run into this problem sooner or later and<a id="id290" class="indexterm"></a> ask yourself what is wrong once you start seeing dead-letter messages in your logs. Once you&#39;ve gone through this once, you can pat yourself on the back and welcome yourself<a id="GBS.0120.01"></a> to the async club. This is an important lesson and you will learn it as you work with the APIs, especially when using ask.</p></div></div></div><div style="display:none;"><a id="GBS.0120.02"></a></div></body></html>