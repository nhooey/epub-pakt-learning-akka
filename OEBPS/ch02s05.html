<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Promises, futures, and event-driven programming models</title><link rel="stylesheet" href="epub.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></meta></head><body id="page"><div style="display:none;"><a id="GBS.0069.01"></a></div><div title="Promises, futures, and event-driven programming models" class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"></a>Promises, futures, and event-driven programming models</h1></div></div></div><p>Before moving on to working <a id="id151" class="indexterm"></a>with more complex Actor-based applications, we need to understand some basic abstractions for working in an event-driven programming model—Promises<a id="id152" class="indexterm"></a> and <a id="id153" class="indexterm"></a>Futures. In <a href="ch01.html" title="Chapter 1. Starting Life as an Actor" class="link">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> we saw how to send a message to an actor and have it invoke some behavior in response to that event. But, what<a id="GBS.0069.02"></a> if we need to get some output from the actor in response to that message? Let&#39;s say we need to get a record from our in-memory key-value store?</p><div title="Blocking versus event-driven APIs" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"></a>Blocking versus event-driven APIs</h2></div></div></div><p>Blocking code is familiar to almost<a id="id154" class="indexterm"></a> any developer. It&#39;s where we start <a id="id155" class="indexterm"></a>when we begin with IO. When we make a call to a synchronous API, the calling method does not return immediately&#8212;the application waits for execution<a id="GBS.0069.03"></a> to complete. For example, if you make an HTTP request, you&#39;ll get back a response object once the request is completed. Code that waits for IO to complete is called blocking as a thread sits and waits&#8212;it is blocked from doing any other work until the IO is complete. We can demonstrate blocking code by showing a query using <a id="id156" class="indexterm"></a>
<span class="strong"><strong>Java Database Connectivity</strong></span> (<span class="strong"><strong>JDBC</strong></span>):</p><div class="informalexample"><pre class="programlisting">      stmt = conn.createStatement();<a id="GBS.0069.04"></a>
      String sql = &quot;select name from users where id=&#39;123&#39;&quot;;
      ResultSet rs = stmt.executeQuery(sql);
      rs.next()
      String name  = rs.getString(&quot;name&quot;);</pre></div><p>Here we retrieve a user&#39;s name from a database using JDBC. The code looks very simple but there are hidden effects that make this simple code less readable:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Latency</strong></span>: It takes time to go over the network to get the result.</li><li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Failure</strong></span>: The<a id="GBS.0069.05"></a> request can fail if, for example, the remote service is unavailable. An exception might be thrown for any number of reasons.</li></ul></div><p>When we call <code class="literal">executeQuery</code>, the thread that is executing this code has to wait for the database query to complete. In a web application, where many users may be making concurrent requests, the finite limit of the thread pool can be reached. There are a limited number of threads<a id="GBS.0070.01"></a> in that thread pool, and if all of them are waiting on IO, then you can&#39;t put any more traffic through the server even if you have free compute resources as there are no threads available to use those resources. If you&#39;ve done any performance tuning on blocking Servlet-based web applications, you may have witnessed the limitations of <code class="literal">threadpool</code>. Usually the CPU will be under-utilized when the<a id="GBS.0070.02"></a> server is at capacity because all of the threads are just waiting.</p><p>This is potentially because the <code class="literal">threadpool</code> is exhausted, or it may also be because the system is spending time loading and unloading the context of threads that need the free CPU time instead of actually doing work on the CPU. Similarly, there are a limited number of threads in the <code class="literal">threadpool</code>. So, if all of the threads are waiting,<a id="GBS.0070.03"></a> the next calls that come into the server cannot be handled until a thread is freed, causing latency to grow.</p><p>So you might ask why we don&#39;t simply use an unlimited <code class="literal">threadpool</code> (create one new thread for every request). Creating a thread has a cost and maintaining many active threads has a cost. When using many threads on a core, the operating system has to context-switch between threads in order<a id="GBS.0070.04"></a> to ensure all of the threads are getting CPU time. The CPU has to unload and store the current thread&#39;s state, and then load in another thread&#39;s context that is waiting for CPU time. If there are 1,000 threads actively working, you can imagine that this may represent a lot of overhead in loading and unloading contexts.</p><p>To summarize, there are a <a id="id157" class="indexterm"></a>few problems with using many threads to <a id="id158" class="indexterm"></a>handle blocking<a id="GBS.0070.05"></a> IO:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Code does not obviously express failure in the response type</li><li style="list-style-type: disc;" class="listitem">Code does not obviously express latency in the response type</li><li style="list-style-type: disc;" class="listitem">Blocking models have throughput limitations due to fixed <code class="literal">threadpool</code> sizes</li><li style="list-style-type: disc;" class="listitem">Creating and using many threads has a performance overhead due to context-switching</li></ul></div><p>A non-blocking asynchronous event-driven system can run with only a handful of threads and will not block those threads,<a id="GBS.0071.01"></a> only using them when computation is needed. This gives the system better responsiveness at scale and can allow better system resource utilization. Depending on the implementation, there can also be a benefit in making effects such as failure and latency more clearly defined in the types, as we&#39;ll see soon.</p><p>The downside is that it can take a bit of time to understand how to write code using event-driven<a id="GBS.0071.02"></a> paradigms. We&#39;ll look at an example of each model to better understand how the two design approaches work.</p><p>First, we&#39;ll look at a very simple call to a database using blocking IO.</p><div class="informalexample"><pre class="programlisting">//Java
String username = getUsernameFromDatabase(userId); System.out.println(username);
//Scala
val username = getUsernameFromDatabase(userId)
println(username)</pre></div><p>The method is invoked and the thread continues into the<a id="GBS.0071.03"></a> method, returning once there is a result.</p><p>If you were debugging, you could step into the method with the thread and see each line of the method <code class="literal">getUsernameFromDatabase</code> method called. Once the actual IO is executed, the thread will sleep until the result comes back. Then the thread returns the method, and jumps back out of the method and continues to print the result.</p><div class="mediaobject"><img src="graphics/B04006_02_02.jpg" alt="Blocking versus event-driven APIs"></img><a id="GBS.0071.04"></a></div><p>The event-driven <a id="id159" class="indexterm"></a>equivalent will look different because <a id="id160" class="indexterm"></a>we have to describe what happens when the completion event occurs, and that code is executed in a different context. To turn our example above into an event-driven equivalent, the code needs to express the print statement as something that happens when the result comes back from the database. It can take some time to adjust to this model,<a id="GBS.0071.05"></a> but you only have to learn it once.</p><p>To move to an event-driven model, we have to express the result in code differently. We have to use placeholders for values that will eventually be there&#8212;a future. The printing of the result is registered as something to do when the completion event occurs. We register some code that we to be invoked when the value the placeholder represents becomes available.<a id="GBS.0072.01"></a> The term &quot;event-driven&quot; describes the way that we express code to execute on certain events:</p><div class="informalexample"><pre class="programlisting">//Java
CompletableFuture&lt;String&gt; usernameFuture = getUsernameFromDatabaseAsync(userId);
usernameFuture.thenRun(username -&gt;
    //executed somewhere else
    System.out.println(username)
);
//Scala val future = getUsernameFromDatabaseAsync(userId)
future.onComplete(username =&gt;
  //executed somewhere else<a id="GBS.0072.02"></a>
  println(username)
)</pre></div><p>From the thread&#39;s perspective, the code will call the method and go into the method, and then return with a Future/Completable Future almost immediately. The result is only a placeholder of the value that will eventually be there.</p><p>We won&#39;t look at the method invocation itself in too much detail&#8212;you should understand that the method will return immediately and the database<a id="GBS.0072.03"></a> call and result will happen somewhere else, on another thread. There is an <code class="literal">ExecutionContext</code> that represents the threads where the other work is done, which we&#39;ll look at later in this book. (In Akka, you&#39;ll see a dispatcher in the <code class="literal">ActorSystem</code>, which is an <code class="literal">ExecutionContext</code> implementation.)</p><p>Note, there is<a id="id161" class="indexterm"></a> a critical difference if you&#39;re trying to debug <a id="id162" class="indexterm"></a>async code&#8212;you won&#39;t see all of the details<a id="GBS.0072.04"></a> of the call to the database on the invoking thread, so you can&#39;t step through the database call from the invoking thread using a debugger like you can in a blocking model. Similarly, if you look at a stack trace from a failure, you may not necessarily see the original calling code&#8212;you&#39;ll see references to another stack where the code is being run.</p><p>After the method returns the future, we only have<a id="GBS.0072.05"></a> the promise of a value that will eventually be there. We don&#39;t want to make the thread wait for the result, but we want to take some action when the result becomes available (print it to the console). The way we do work in an event-driven system is to describe the code to run when an event happens. In an actor, we describe the behavior to use when a message is received. Similarly, with a future,<a id="GBS.0073.01"></a> we describe the behavior to execute when the future&#39;s value becomes available. The methods on a future to register code to run on the successful completion event successfully with then Run (Java8) or on Complete (Scala).</p><div class="mediaobject"><img src="graphics/B04006_02_03.jpg" alt="Blocking versus event-driven APIs"></img><a id="GBS.0073.02"></a></div><p>It&#39;s important to highlight again—the print statement will not run on the thread that registers the event. It will run somewhere else, on another thread via the <code class="literal">ExecutionContext</code>. Futures are always created with <code class="literal">ExecutionContext</code>, so you can choose where to run them.</p><p>All of the variables<a id="id163" class="indexterm"></a> in scope are available to the lambda<a id="id164" class="indexterm"></a> registered. Methods, however, should be invoked with special care, or simply<a id="GBS.0073.03"></a> should not be invoked within the closures, as they won&#39;t be invoked in the same lexical scope. We&#39;ll look at this gotcha in the next chapter.</p><p>Note that futures can fail and should always be bounded by a timeout (required in the Scala API) so they will not hang around forever and will always finish—either successfully or with failure. We&#39;ll take a closer look at handling futures now.</p><div title="Skills check-point" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec16"></a>Skills check-point</h3></div></div></div><p><a id="GBS.0073.04"></a>Scala developers should be<a id="id165" class="indexterm"></a> familiar with using higher order functions/lambdas. It would be helpful for the developer to have some familiarity with the option or try types to ensure the material is fast to understand.</p><p>If you&#39;re using Java8, it&#39;s a good time to check in and see if you&#39;re comfortable reading the code examples so far. If you&#39;re unclear on the use of lambdas, you should take the time<a id="GBS.0073.05"></a> now to go through the <a id="id166" class="indexterm"></a>Oracle Java8 lambda primer, which can be found at <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" class="ulink">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html</a>.</p><p>You should get some experience working with them by exploring the Stream API and the Optional type. The Optional type is helpful to learn as it&#39;s semantically similar in its use to <code class="literal">CompletableFuture</code>.</p><p>Understanding the following material<a id="GBS.0074.01"></a> will be easier if you have some experience to relate the material to first.</p></div></div><div title="Having an Actor respond via a future" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"></a>Having an Actor respond via a future</h2></div></div></div><p>We looked at a <a id="id167" class="indexterm"></a>hypothetical example of an asynchronous <a id="id168" class="indexterm"></a>database call, where the result of a call to the database completes a future. We&#39;ll introduce a real example now by communicating with the example actors that we built earlier in this chapter—the <code class="literal">PongActor</code>. We&#39;ll have a way<a id="GBS.0074.02"></a> of communicating with actors from outside the actor system after this so that we can use Akka to build the core of an application or library and use it from plain Java or Scala code.</p><p>While the test case here does introduce the asynchronous API, the test cases are still blocking by awaiting the result. This is useful in demonstrating another way of handling Akka in your test cases. We need the<a id="GBS.0074.03"></a> test cases to block because, if we don&#39;t wait for the result, the test case will always return immediately and, hence, will always pass.</p><p>You should build<a id="id169" class="indexterm"></a> these test cases and use them to explore the future <a id="id170" class="indexterm"></a>API introduced in the next section to understand it well. By building these examples, you&#39;ll always have a sandbox you can return to if you need to further examine how futures work. They are<a id="GBS.0074.04"></a> included in the source code for this book as well.</p><div title="Java example" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec17"></a>Java example</h3></div></div></div><p>We&#39;ll cover the Java8 examples<a id="id171" class="indexterm"></a> first. Akka is built in Scala, and, generally, the Scala and Java APIs are one to one. There is a notable exception and that is that all asynchronous methods that return a future will return the Scala <code class="literal">scala.concurrent.Future</code>.</p><div title="Working with Scala futures" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec10"></a>Working with Scala futures</h4></div></div></div><p>For the <a id="id172" class="indexterm"></a>Java examples, we need a way to handle<a id="GBS.0074.05"></a> Scala futures&#8212;in this <a id="id173" class="indexterm"></a>book, we&#39;ll convert them to the Java8 <code class="literal">CompletableFuture</code>.</p><p>The Play Promise API is also a good choice if you&#39;re building a Play application. I personally prefer the semantics used in the Play Promise API over the Java8 <code class="literal">CompletableFuture</code> API, but the Java8 API may be more readable for those not accustomed to working with asynchronous code yet. It&#39;s recommended if your code may<a id="GBS.0075.01"></a> be placed into a library that you use the Java8 <code class="literal">CompletableFuture</code> so you do not have a dependency on Play in your code outside the controller.</p><p>To start, we need to add this dependency from the Scala team to your <code class="literal">build.sbt</code> to be able to convert between Scala and Java8 Futures:</p><div class="informalexample"><pre class="programlisting">&quot;org.scala-lang.modules&quot; %% &quot;scala-java8-compat&quot; % &quot;0.6.0&quot;</pre></div></div><div title="Test case" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec11"></a>Test case</h4></div></div></div><p>The following is the complete<a id="id174" class="indexterm"></a> test case. Next,<a id="GBS.0075.02"></a> we&#39;ll look at each element of the APIs in detail:</p><div class="informalexample"><pre class="programlisting">package pong;
//[...imports] 
import static scala.compat.java8.FutureConverters.*;
public class PongActorTest { 
    ActorSystem system = ActorSystem.create(); 
    ActorRef actorRef = 
            system.actorOf(Props.create(JavaPongActor.class)); 
    @Test
    public void shouldReplyToPingWithPong() throws Exception { 
        Future sFuture<a id="GBS.0075.03"></a> = ask(actorRef, &quot;Ping&quot;, 1000); 
        final CompletionStage&lt;String&gt; cs = toJava(sFuture); 
        final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs; 
        assert(jFuture.get(1000, TimeUnit.MILLISECONDS).equals(&quot;Pong&quot;)); 
    }
    @Test(expected = ExecutionException.class) 
    public void shouldReplyToUnknownMessageWithFailure() throws Exception { 
        Future sFuture<a id="GBS.0075.04"></a> = ask(actorRef, &quot;unknown&quot;, 1000); 
        final CompletionStage&lt;String&gt; cs = toJava(sFuture); 
        final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs; 
        jFuture.get(1000, TimeUnit.MILLISECONDS); 
    }
}</pre></div><p>Our Pong Actor <a id="id175" class="indexterm"></a>test has a test for both the success case and failure case.</p></div><div title="Actor creation" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec12"></a>Actor creation</h4></div></div></div><p>We begin by <a id="id176" class="indexterm"></a>creating an <code class="literal">ActorSystem</code>, and then an actor in that actor<a id="GBS.0075.05"></a> system with <code class="literal">actorOf</code>, as previously covered:</p><div class="informalexample"><pre class="programlisting">ActorSystem system = ActorSystem.create();
ActorRef actorRef = 
system.actorOf(Props.create(JavaPongActor.class));</pre></div><p>Now, we ask the actor for a response to a message:</p><div class="informalexample"><pre class="programlisting">final Future sFuture = ask(actorRef, &quot;Ping&quot;, 1000);</pre></div><p>This is fairly straightforward—we call the ask method, passing:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">The actor ref to send the message to</li><li style="list-style-type: disc;" class="listitem">The message we want to send the actor</li><li style="list-style-type: disc;" class="listitem"><a id="GBS.0076.01"></a>The timeout for the future&#8212;how long to wait for a result before considering it a failure</li></ul></div><p>This gives us back the placeholder of the response we&#39;ll get in the future—a Scala Future. In the actor code, the actor will send a message back to <code class="literal">sender()</code>, which we will receive as the response to this future.</p><p>We can&#39;t use the Scala Future from Java8, but we can convert it with the library we imported earlier:</p><div class="informalexample"><pre class="programlisting"><a id="GBS.0076.02"></a>final CompletionStage&lt;String&gt; cs = toJava(sFuture); final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs;</pre></div><p>We first convert the Scala future with <code class="literal">scala.compat.java8.FutureConverters.toJava</code>,<code class="literal"> </code>which gives us a <code class="literal">CompletionStage</code>. The <code class="literal">CompletionStage</code> is the interface for the <code class="literal">CompletableFuture</code>&#8212;specifically it is a read-only interface. In this case, we cast the future to gain access to<a id="GBS.0076.03"></a> the get method. You won&#39;t need to cast the <code class="literal">CompletionStage</code> outside of test cases.</p><p>Note that we&#39;re <a id="id177" class="indexterm"></a>placing a String type on the future. Actors are untyped and return an Object, so you may find the unchecked casting a little iffy. Certainly, some care is needed when talking to Actors from outside of the <code class="literal">ActorSystem</code> in this regard. We know that the Actor will always return a String on this message,<a id="GBS.0076.04"></a> though, so it&#39;s a safe assertion that the type of the future is a String.</p><p>Finally, we call the <code class="literal">get()</code> method to block the thread in the tests and get the result. In the failure test, the get method will throw an exception—it will throw the <code class="literal">akka.status.Failure</code> message&#39;s exception, which is sent from the actor.</p><p>You now have an example of a successful and failing future to experiment with!</p></div></div><div title="Scala example" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"></a>Scala<a id="GBS.0076.05"></a> example</h3></div></div></div><p>Next, we&#39;ll cover the Scala example<a id="id178" class="indexterm"></a>. Akka gives Scala futures, so the test is a bit simpler.</p><div title="Test case" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec13"></a>Test case</h4></div></div></div><p>The following is the complete Scala <a id="id179" class="indexterm"></a>test case. Next, we&#39;ll cover the test in detail:</p><div class="informalexample"><pre class="programlisting">package pong
//[...imports]
import akka.pattern.ask import scala.concurrent.duration._ 
class ScalaAskExamplesTest extends FunSpecLike with Matchers { val system = ActorSystem() implicit val timeout<a id="GBS.0077.01"></a> = Timeout(5 seconds) val pongActor = system.actorOf(Props(classOf[ScalaPongActor])) describe(&quot;Pong actor&quot;) { it(&quot;should respond with Pong&quot;) { val future = pongActor ? &quot;Ping&quot; //uses the implicit timeout val result = Await.result(future.mapTo[String], 1 second) assert(result == &quot;Pong&quot;) }it(&quot;should fail on unknown message&quot;) { val future = pongActor ? &quot;unknown&quot; intercept[Exception]{ Await.result(future.mapTo[String],<a id="GBS.0077.02"></a> 1 second)
      }
    }
  }
}</pre></div></div><div title="Actor creation" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec14"></a>Actor creation</h4></div></div></div><p>We begin by creating an <code class="literal">ActorSystem</code> and then creating an actor in that actor system with <code class="literal">actorOf</code>, as <a id="id180" class="indexterm"></a>previously covered.</p><p>We also create an implicit <code class="literal">Timeout</code> for the future creation (note that the import of <code class="literal">scala.concurrent.duration</code> is needed for the duration passed in to the Timeout):</p><div class="informalexample"><pre class="programlisting">  implicit val system = ActorSystem()
  implicit val timeout =<a id="GBS.0077.03"></a> Timeout(5 seconds)
  val pongActor = system.actorOf(Props(classOf[ScalaPongActor]))</pre></div><p>Now, we ask the actor for a response to a message:</p><div class="informalexample"><pre class="programlisting">val future = pongActor ? &quot;Ping&quot;</pre></div><div title="Note" style="" class="note"><div class="inner"><h3 class="title"><a id="tip05"></a>Tip</h3><p>We need to import <code class="literal">akka.pattern.ask</code> for this to work.</p></div></div><p>The call to ask references:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">The actor ref to send the message to <code class="literal">pongActor</code></li><li style="list-style-type: disc;" class="listitem">The message we want to send the actor</li><li style="list-style-type: disc;" class="listitem">Implicitly, the timeout for the future&#8212;how long to wait for<a id="GBS.0077.04"></a> a result before considering it a failure</li></ul></div><p>This gives us back a placeholder—a Future—that represents the actor&#39;s reply. In the actor code, the actor will send a message back to <code class="literal">sender()</code>, which we will receive as the response to this future.</p><p>Finally, we want to block the test until we have the result available. We use <code class="literal">Await.result</code> on the future with a timeout value:</p><div class="informalexample"><pre class="programlisting">val result = Await.result(future.mapTo[String],<a id="GBS.0077.05"></a> 1 second)</pre></div><p>The Actor is untyped, so we get back a <code class="literal">Future[AnyRef].</code> We call <code class="literal">future.mapTo[String]</code> to change the future&#39;s type to the expected type of the result.</p><p>You can build on this example now—play around with the Future API as we continue through the next sections of this chapter.</p></div></div><div title="Blocking threads in tests" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec19"></a>Blocking threads in tests</h3></div></div></div><p>Asking an actor<a id="id181" class="indexterm"></a> for a response demonstrates how to talk to an actor <a id="id182" class="indexterm"></a>from outside the<a id="GBS.0078.01"></a> actor system by getting a response via a future. In this test case, we sleep/block the test thread by calling get <code class="literal">Await.result</code> in order to get the result out of the future synchronously.</p><p>This is fine in test cases&#8212;it&#39;s actually necessary or the test will complete before the result is available&#8212;however, blocking is a bad practice anywhere other than in test cases. You should only have non-blocking<a id="GBS.0078.02"></a> code outside of the test context.</p><div title="Note" style="" class="note"><div class="inner"><h3 class="title"><a id="tip06"></a>Tip</h3><p>Don&#39;t sleep or block outside tests.</p></div></div><p>In tests, the preferred way to block with the Java8 completable future is to call the get() method on the Future. The get() method will block the thread until the result is available:</p><div class="informalexample"><pre class="programlisting">jFuture.get().equals(&quot;Pong&quot;)</pre></div><p>While <code class="literal">get()</code> will sleep forever if you don&#39;t specify a timeout, the Scala future requires a timeout (specified<a id="GBS.0078.03"></a> in the ask method), so the future will fail if the timeout is violated.</p><p>Getting the result from the Scala Future can be accomplished by using <code class="literal">scala.concurrent.Await.result</code>:</p><div class="informalexample"><pre class="programlisting">import scala.concurrent.duration._ val result: String = Await.result(future.mapTo[String], 1 second)</pre></div><p>Here the timeout is required—it&#39;s redundant as the ask method has already placed a timeout on the future.</p><p>In both the Java<a id="GBS.0078.04"></a> and Scala examples, if the future fails, blocking will result in the exception that the future failed with being thrown. The Java8 <code class="literal">CompletableFuture</code> will throw an <code class="literal">ExecutionException</code> caused by the <code class="literal">Throwable</code> the future fails with. The Scala API will throw the actual <code class="literal">Throwable</code>. (Scala has no checked exceptions, so the API can do this—Java throws an unchecked exception type here.)</p><p>You now have an<a id="GBS.0078.05"></a> example of a future that you can work with and mechanisms to build test cases to examine the results. We will begin to cover the future APIs in depth now as they are crucial to understand when working with asynchronous code. It is highly recommended you explore the future API inside these test cases. To save some typing, the examples are available in the <a href="ch02.html" title="Chapter 2. Actors and Concurrency" class="link">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> code<a id="GBS.0079.01"></a> bundle available online.</p></div></div><div title="Understanding futures and promises" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"></a>Understanding futures and promises</h2></div></div></div><p>Modern futures make two effects <a id="id183" class="indexterm"></a>implicit: failure and latency. To see how we can move from blocking<a id="id184" class="indexterm"></a> IO to non-blocking IO, we must learn some abstractions that express handling with failure and latency in different ways. It may seem difficult at first, but most developers find they take to the paradigm once they begin to understand<a id="GBS.0079.02"></a> it.</p><div title="Future – expressing failure and latency in types" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"></a>Future – expressing failure and latency in types</h3></div></div></div><p>An asynchronous API, such<a id="id185" class="indexterm"></a> as the ask pattern, will return one of the<a id="id186" class="indexterm"></a> placeholder future types mentioned previously. We can try to demonstrate how the code becomes clearer by looking at different ways in which we can work with our <code class="literal">PongActor</code> in the test case. It&#39;s very strongly advised that you do follow along in this section with the test case<a id="GBS.0079.03"></a> we built previously.</p><div title="Preparing for the Java example" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec15"></a>Preparing for the Java example</h4></div></div></div><p>First, for the <a id="id187" class="indexterm"></a>Java8 examples, we&#39;ll simplify the ask by placing it into a method to eliminate duplication. This now looks like a real asynchronous API:</p><div class="informalexample"><pre class="programlisting">public CompletionStage&lt;String&gt; askPong(String message){ Future sFuture = ask(actorRef, &quot;Ping&quot;, 1000); CompletionStage&lt;String&gt; cs = toJava(sFuture); return cs;
}</pre></div><p>Then we&#39;ll build simple test<a id="GBS.0079.04"></a> cases:</p><div class="informalexample"><pre class="programlisting">@Test public void printToConsole() throws Exception { 
    askPong(&quot;Ping&quot;).
        thenAccept(x -&gt; System.out.println(&quot;replied with: &quot; + x)); 
    Thread.sleep(100); 
}</pre></div></div><div title="Preparing for Scala examples" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec16"></a>Preparing for Scala examples</h4></div></div></div><p>We&#39;ll start by<a id="id188" class="indexterm"></a> defining a simple method to remove any redundancy and make the examples a bit easier to read:</p><div class="informalexample"><pre class="programlisting">def askPong(message: String): Future[String] = (pongActor ? message).mapTo[String]</pre></div><p><a id="GBS.0079.05"></a>We&#39;re going to look at asynchronous work running on multiple threads, so you&#39;ll need to import an implicit <code class="literal">ExecutionContext</code> now.</p><p>We can make a test case like the following to play around in:</p><div class="informalexample"><pre class="programlisting">describe(&quot;FutureExamples&quot;){
  import scala.concurrent.ExecutionContext.Implicits.global
  it(&quot;should print to console&quot;){
    (pongActor ? &quot;Ping&quot;).onSuccess({
      case x: String =&gt; println(&quot;replied with: &quot;<a id="GBS.0080.01"></a> + x)     })
    Thread.sleep(100) }
}</pre></div></div><div title="Note on sleeping" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec17"></a>Note on sleeping</h4></div></div></div><p>This test doesn&#39;t yet make any <a id="id189" class="indexterm"></a>assertions, but shows a test with real asynchronous behavior now. This test isn&#39;t helpful, but we can see if it works by looking for the effects (we expect to print to the console in this case). If you want events to occur asynchronously, you may occasionally need to sleep tests. As with blocking, sleeping<a id="GBS.0080.02"></a> is OK in tests but should never be done in real code.</p><p>While these tests don&#39;t actually test anything, they&#39;re useful for experimenting to see the effects occur asynchronously. We&#39;ll look at how to make assertions in asynchronous code after taking some time to understand futures.</p></div><div title="Anatomy of a future" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec18"></a>Anatomy of a future</h4></div></div></div><p>A <code class="literal">Future[T]/CompletableFuture&lt;T&gt;</code> can either be successful with a value of type <code class="literal">T</code> or a failure<a id="GBS.0080.03"></a> of <a id="id190" class="indexterm"></a>type <code class="literal">Throwable</code>. We&#39;ll look at how to handle each case—success and failure—and how to transform the future&#39;s value to be able to do useful things with the result.</p></div><div title="Handling success cases" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec19"></a>Handling success cases</h4></div></div></div><p>As we saw in <a id="id191" class="indexterm"></a>our test, the <code class="literal">PongActor</code> will reply with &quot;Pong&quot; if it <a id="id192" class="indexterm"></a>receives &quot;Ping.&quot; We&#39;ll work with this example to demonstrate different ways we can interact with the future.</p><div title="Executing code with the result" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec01"></a>Executing code with the result</h5></div></div></div><p><a id="GBS.0080.04"></a>Sometimes we <a id="id193" class="indexterm"></a>need to simply &quot;do something&quot; with the result. Maybe we want to log the event or maybe we want to send a response over the network. We can &quot;register&quot; events  to occur once the result becomes available.</p><p>As demonstrated, we can use <code class="literal">thenAccept</code> to consume the value in Java8:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;Ping&quot;).thenAccept(x -&gt; System.out.println(&quot;replied with: &quot; + x));</pre></div><p>And, in Scala, we can use onSuccess:</p><div class="informalexample"><pre class="programlisting"><a id="GBS.0080.05"></a>(pongActor ? &quot;Ping&quot;).onSuccess(){ case x: String =&gt; println(&quot;replied with: &quot; + x) })</pre></div><div title="Note" style="" class="note"><div class="inner"><h3 class="title"><a id="tip07"></a>Tip</h3><p>Note that <code class="literal">onSuccess</code> takes a partial function, so it fits well with the Akka untyped <a id="id194" class="indexterm"></a>responses—pattern matching takes care of determining the type of the result.</p></div></div></div><div title="Transforming the result" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec02"></a>Transforming the result</h5></div></div></div><p>The most common use<a id="id195" class="indexterm"></a> case is the need to transform a response asynchronously before doing something with it. For example,<a id="GBS.0081.01"></a> we may need to get data from a database and then transform that into an HTTP response to give back to a client.</p><p>Transformation of a value is done with map in most APIs, as it is with Scala&#39;s Future:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;Ping&quot;).map(x =&gt; x.charAt(0))</pre></div><p>In Java8, we call <code class="literal">thenApply:</code>
</p><div class="informalexample"><pre class="programlisting">askPong(&quot;Ping&quot;).thenApply(x -&gt; x.charAt(0))</pre></div><p>These will give you back new Futures of type <code class="literal">Char</code>. You can transform the result and then<a id="GBS.0081.02"></a> pass the modified future on to other methods for further processing.</p></div><div title="Transforming the result asynchronously" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec03"></a>Transforming the result asynchronously</h5></div></div></div><p>If we need to make an asynchronous call, and then make another asynchronous call with the result of the first, it could start to look a little bit messy: </p><div class="informalexample"><pre class="programlisting">//Java CompletionStage&lt;CompletionStage&lt;String&gt;&gt; futureFuture = askPong(&quot;Ping&quot;).thenApply(x -&gt; askPong(x)); //Scala val futureFuture:<a id="GBS.0081.03"></a> Future[Future[String]] = askPong(&quot;Ping&quot;).map(x =&gt; { askPong(x) })</pre></div><p>Very often you&#39;ll need to make an asynchronous call, and then make another asynchronous call as we have done in this example. However, right now, our result is buried inside a future inside another future! This is very difficult to work with&#8212;what we want to do instead is to flatten that out so the result is inside of a single future,<a id="GBS.0081.04"></a> we want a <code class="literal">Future[String]/CompletionStage[String]</code>.</p><p>There are ways to compose our futures to make these chained asynchronous operations. using <code class="literal">thenCompose</code> in Java:</p><div class="informalexample"><pre class="programlisting">CompletionStage&lt;String&gt; cs = askPong(&quot;Ping&quot;).thenCompose(x -&gt; askPong(&quot;Ping&quot;));

Orpredictably, flatMap in Scala:

val f: Future[String] = askPong(&quot;Ping&quot;).flatMap(x =&gt; askPong(&quot;Ping&quot;))</pre></div><p>Once the first &quot;Ping&quot; is responded to, then we send<a id="GBS.0081.05"></a> a second &quot;Ping&quot; and return the response as the value of the future.</p><p>Note you can<a id="id196" class="indexterm"></a> continue to string together asynchronous computation like this. This is a very powerful way of handling pipelines of data processing. You can make a call to a remote service and then make a call to a second service with the result.</p><p>A failure on either call will cause the entire future to fail. We&#39;ll look at failure<a id="GBS.0082.01"></a> cases next.</p></div></div><div title="Handling failure cases" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec20"></a>Handling failure cases</h4></div></div></div><p>Failures can <a id="id197" class="indexterm"></a>occur and we need to handle those failures as well. Failures<a id="id198" class="indexterm"></a> always have a cause represented by a <code class="literal">Throwable</code>. Similar to the success cases, there are methods that allow us to handle the failure or even recover from it.</p><div title="Executing code in the failure case" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec04"></a>Executing code in the failure case</h5></div></div></div><p>Very often you <a id="id199" class="indexterm"></a>will want to do something with a failure. The most basic case is to log something<a id="GBS.0082.02"></a> in the case of failure.</p><p>In Scala, there is a simple way to do this—<code class="literal">onFailure</code>. This method accepts a partial function accepting a <code class="literal">Throwable</code>:</p><div class="informalexample"><pre class="programlisting">    askPong(&quot;causeError&quot;).onFailure{ case e: Exception =&gt; println(&quot;Got exception&quot;) } }</pre></div><p>Unfortunately, in Java8, there is no consumer-based method for failure, so we will introduce <code class="literal">handle()</code> here for this case:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;cause error&quot;).handle((x, t) -&gt; { if(t!=null){System.out.p<a id="GBS.0082.03"></a>rintln(&quot;Error: &quot; + t); } return null; });</pre></div><p>Handle takes a <code class="literal">BiFunction</code> that transforms either the success or failure case. The function in handle will provide you with either the successful result or the <code class="literal">Throwable</code>, so we have to check to see if the <code class="literal">Throwable</code> is present (only the result or the <code class="literal">Throwable</code> will be not null). If the <code class="literal">Throwable</code> is present, then we log the statement. We have to return a value<a id="GBS.0082.04"></a> on the function, so we simply return null as we&#39;re not doing anything with the value in the failure case.</p></div><div title="Recovering from failure" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec05"></a>Recovering from failure</h5></div></div></div><p>Often we want <a id="id200" class="indexterm"></a>to use a value if there is an error. If you want to recover from failure, you transform the future to have a successful value.</p><p>In Java, we can use exceptionally to take the <code class="literal">Throwable</code> and transform it into a usable value:</p><div class="informalexample"><pre class="programlisting">        CompletionStage&lt;String&gt;<a id="GBS.0082.05"></a> cs = askPong(&quot;cause error&quot;).exceptionally(t -&gt; { return &quot;default&quot;; });</pre></div><p>In Scala, there is a recover method that is the equivalent. Again, this takes a <code class="literal">PartialFunction</code>, so we can pattern match on the exception type:</p><div class="informalexample"><pre class="programlisting">      val f = askPong(&quot;causeError&quot;).recover{ case t: Exception =&gt; &quot;default&quot; }</pre></div></div><div title="Recovering from failure asynchronously" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec06"></a>Recovering from failure asynchronously</h5></div></div></div><p>Often we&#39;ll need to recover from <a id="id201" class="indexterm"></a>failure with another asynchronous<a id="GBS.0083.01"></a> operation. A few use cases could be:</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Retrying a failed operation</li><li style="list-style-type: disc;" class="listitem">A cold hit to a cache requires making an operation to another service</li></ul></div><p>We&#39;ll demonstrate a retry as follows:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;cause error&quot;)
        .handle( (pong, ex) -&gt; ex == null 
                ? CompletableFuture.completedFuture(pong) 
                : askPong(&quot;Ping&quot;)
        ).thenCompose(x -&gt; x);</pre></div><p>We have to do this in two steps. First,<a id="GBS.0083.02"></a> we check if the exception is not null and return either a future of the result or the new retry future. Then we call <code class="literal">thenCompose</code> to <code class="literal">flatten</code> the <code class="literal">CompletionState[CompletionStage[String]]</code>. </p><p>In Scala, <code class="literal">recoverWith</code> is the function we want to invoke—this is like <code class="literal">flatMap</code> for the error case, so is considerably more readable and succinct than the Java equivalent:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;causeError&quot;).recoverWith({ case<a id="GBS.0083.03"></a> t: Exception =&gt; askPong(&quot;Ping&quot;) })</pre></div></div></div><div title="Composing futures" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec21"></a>Composing futures</h4></div></div></div><p>Often we&#39;ll have<a id="id202" class="indexterm"></a> multiple operations we need to do and maybe we&#39;ll want to do them in different places in the codebase. Each call to the methods covered returns a new future that can have additional operations applied to it.</p><div title="Chaining operations together" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec07"></a>Chaining operations together</h5></div></div></div><p>We&#39;ve covered the <a id="id203" class="indexterm"></a>basics of working with futures. One of the benefits of working with<a id="GBS.0083.04"></a> latency and failure in a functional style is that it&#39;s easy to compose together multiple operations without having to handle exceptions along the way. We can focus on the happy path and then collect errors at the end of the chain of operations.</p><p>Each of the methods that transforms a value covered returns a new future that can then be dealt with and chained into more operations.</p><p>Putting it all together,<a id="GBS.0083.05"></a> we may have several operations and then one recovery function at the end to deal with any errors that may have occurred. It&#39;s possible to combine these functions (aka combinators) in any order you can dream up to accomplish the work you need to get done.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;Ping&quot;).
    thenCompose(x -&gt; askPong(&quot;Ping&quot; + x)).
    handle((x, t) -&gt; { if(t != null){ return &quot;default&quot;; }else{ return x;<a id="GBS.0084.01"></a> } });</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">val f = askPong(&quot;Ping&quot;).
  flatMap(x =&gt; askPong(&quot;Ping&quot; + x)).
  recover({ case Exception =&gt; &quot;There was an error&quot; })</pre></div><p>In these examples, we get a future, then call <code class="literal">thenCompose</code>/<code class="literal">flatMap</code> to asynchronously make a call when the first completes, and then, in the case of an error, we recover with a String value to ensure the future is successful.</p><p>Any failure along the way becomes the failure<a id="GBS.0084.02"></a> at the end of the chain. This leaves us with an elegant pipeline of operations where exceptions are handled at the end regardless of which operation caused the failure. We can focus on describing the happy path without extraneous error checking throughout the pipeline. At the end, failure as an effect is described separately.</p></div><div title="Combining futures" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec08"></a>Combining futures</h5></div></div></div><p>You&#39;ll often have<a id="id204" class="indexterm"></a> multiple futures executing that<a id="GBS.0084.03"></a> you need to get access to. There are facilities for handling these cases as well. In Java, the <code class="literal">thenCombine</code> method on <code class="literal">CompletableFuture</code> will let you access the values of two futures once they are available:</p><div class="informalexample"><pre class="programlisting">askPong(&quot;Ping&quot;).
    thenCombine(askPong(&quot;Ping&quot;), (a,b) -&gt; { return a + b; //&quot;PongPong&quot; });</pre></div><p>In Scala, for comprehensions offer an alternative syntax for composing together several futures. We&#39;re<a id="GBS.0084.04"></a> able to extract the results of two futures and handle them together like we would with any other collection. (Note that this is syntactic sugar for <code class="literal">flatMap</code>—I prefer this notation over <code class="literal">flatMap</code>.):</p><div class="informalexample"><pre class="programlisting">val f1 = Future{4} val f2 = Future{5} val futureAddition: Future[Int] = for( res1 &lt;- f1; res2 &lt;- f2 ) yield res1 + res2</pre></div><p>These examples yield simple mechanisms for handling multiple futures of varying types.<a id="GBS.0084.05"></a> In this way, we can parallelize work, making multiple requests at the same time to get responses back to users faster. This use of parallelization can help us improve system responsiveness.</p></div><div title="Dealing with lists of futures" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec09"></a>Dealing with lists of futures</h5></div></div></div><p>If you have a collection<a id="id205" class="indexterm"></a> and you execute an asynchronous method on each element, you&#39;ll end up with a list of Futures.</p><p>For example, in Scala, if we take a list of messages,<a id="GBS.0085.01"></a> and ask the Pong actor to reply to each method, we end up with a list of futures like the following:</p><div class="informalexample"><pre class="programlisting">val listOfFutures = List[Future[String]] = List(&quot;Pong&quot;, &quot;Pong&quot;, &quot;failed&quot;).map(x =&gt; askPong(x))</pre></div><p>If you try to work with that, you&#39;ll see it&#39;s not easy. What we want is to get at the list of results—really, we want to flip the types so the <code class="literal">List[Future]</code> becomes <code class="literal">Future[List]</code>. This is a job for sequence,<a id="GBS.0085.02"></a> which is a member of Future:</p><div class="informalexample"><pre class="programlisting">val futureOfList: Future[List[String]] = Future.sequence(listOfFutures)</pre></div><p>Now we have a usable type. If we call map on <code class="literal">futureOfList</code>, for example, we get a <code class="literal">List[String]</code>, which is what we want to work with. There is a problem here though. The future generated by sequence will fail if any of the futures in the list fail. We can recover each future before sequencing if we<a id="GBS.0085.03"></a> want to get any successful values instead of failing everything:</p><div class="informalexample"><pre class="programlisting">Future.sequence(listOfFutures.map(future =&gt; future.recover{case Exception =&gt; &quot;&quot;}))</pre></div><p>There is no<a id="id206" class="indexterm"></a> equivalent in the Java8 core library, but there are gists around that cover the functionality for sequencing futures in the same manner.</p></div><div title="Future cheat-sheet" class="section"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec10"></a>Future cheat-sheet</h5></div></div></div><p>The following is a <a id="id207" class="indexterm"></a>small chart outlining the basic operations covered:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left;"></col><col style="text-align: left;"></col><col style="text-align: left;"></col></colgroup><thead><tr><th style="text-align: left;" valign="bottom">
<p>Operation</p><a id="GBS.0085.04"></a>
</th><th style="text-align: left;" valign="bottom">
<p>Scala Future</p>
</th><th style="text-align: left;" valign="bottom">
<p>Java CompletableFuture</p>
</th></tr></thead><tbody><tr><td style="text-align: left;" valign="top">
<p>Transform Value</p>
</td><td style="text-align: left;" valign="top">
<p>.map(x =&gt; y)</p>
</td><td style="text-align: left;" valign="top">
<p>.thenApply(x -&gt; y)</p>
</td></tr><tr><td style="text-align: left;" valign="top">
<p>Transform Value Async</p>
</td><td style="text-align: left;" valign="top">
<p>.flatMap(x =&gt; futureOfY)</p>
</td><td style="text-align: left;" valign="top">
<p>.thenCompose(x -&gt; futureOfY)</p>
</td></tr><tr><td style="text-align: left;" valign="top">
<p>Return Value if Error</p>
</td><td style="text-align: left;" valign="top">
<p>.recover(t =&gt; y)</p>
</td><td style="text-align: left;" valign="top">
<p>.exceptionally(t -&gt; y)</p>
</td></tr><tr><td style="text-align: left;" valign="top">
<p>Return Value Async if Error</p>
</td><td style="text-align: left;" valign="top">
<p>.recoverWith(t =&gt; futureOfY)</p>
</td><td style="text-align: left;" valign="top">
<p>.handle(t,x -&gt; futureOfY).thenCompose(x-&gt;x)</p>
</td></tr></tbody></table></div><p>This section gives a good overview of the future<a id="GBS.0085.05"></a> and promises APIs. It&#39;s necessary to understand this abstraction, so it&#39;s recommended that you work with some asynchronous code and futures to get a better grasp on this. In the next section, we will introduce how to interact with actors by getting futures back&#8212;you should take some time to practice this to see how to handle multiple future results to ensure you have a good foundation to build<a id="GBS.0086.01"></a> on.</p></div></div><div title="Composing a Distributed System – AkkademyDb and client" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec22"></a>Composing a Distributed System – AkkademyDb and client</h4></div></div></div><p>The purpose of this <a id="id208" class="indexterm"></a>book is to teach you how to build distributed applications, so we&#39;re going to put everything we&#39;ve covered in this chapter together into a small distributed application. While the code is fairly simple, this example is a bit advanced in its structure in that it jumps right in to showing you how two remote systems<a id="GBS.0086.02"></a> can use Akka to talk, but I think it&#39;s important to see the power of Akka right away to keep you interested in the material. If you get a taste for what Akka can do for you now, you&#39;ll want to keep going through the remaining chapters.</p><p>We&#39;ll be building a client and a service&#8212;our database&#8212;and then a database client to talk to it. In order to send messages over the wire between the client and service,<a id="GBS.0086.03"></a> we need to share messages between the projects.</p><p>We could put the messages<a id="id209" class="indexterm"></a> in their own project, but to keep the examples shorter, we&#39;ll put the messages in the server project and import the server project (and, hence, the messages) into the client project.</p><div class="mediaobject"><img src="graphics/B04006_02_04.jpg" alt="Composing a Distributed System – AkkademyDb and client"></img><a id="GBS.0086.04"></a></div><p>We&#39;ll start by extending the server project from the first chapter and producing all of the messages we want the database to expose. Then we&#39;ll implement the features for those messages in the database.</p><p>After building these basic operations, we&#39;ll produce a <code class="literal">main()</code> to make the store runnable. We&#39;ll start the application by producing an <code class="literal">ActorSystem</code> and the Actor in the <code class="literal">ActorSystem</code>, creating our<a id="GBS.0086.05"></a> first Akka &quot;micro-service.&quot;</p><p>To consume the service and demonstrate how we can get futures from our remote actors, we&#39;ll create the database client to use the service. We&#39;ll expose the service in the client by returning futures. At this point, we&#39;ll have built a usable key-value datastore, much like redis, and a remote client to consume it.</p></div></div></div><div title="Preparing the DB and messages" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"></a>Preparing the DB and messages</h2></div></div></div><p>We want to <a id="id210" class="indexterm"></a>expose a<a id="id211" class="indexterm"></a><a id="GBS.0087.01"></a> few messages to start with.</p><div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Get message: Return a key if it exists</li><li style="list-style-type: disc;" class="listitem">Key Not Found exception: If a key isn&#39;t found, return this failure</li><li style="list-style-type: disc;" class="listitem">Set message: Sets a value and reply with a status</li></ul></div><p>In the server, we&#39;ll implement these messages, their behavior, and a main so that the datastore can run. Note, we&#39;ll use the project from <a href="ch01.html" title="Chapter 1. Starting Life as an Actor" class="link">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span>, adding features <a id="id212" class="indexterm"></a>introduced in this chapter<a id="GBS.0087.02"></a> such as replying and replying with<a id="id213" class="indexterm"></a> failure.</p><div title="The messages" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"></a>The messages</h3></div></div></div><p>As we&#39;ll be using remoting to send<a id="id214" class="indexterm"></a> messages between separate networked applications, we need all of the messages to be serializable so that Akka can turn them into representations of the objects as they transfer over the networks between the applications. We&#39;ll implement <code class="literal">SetRequest</code>, <code class="literal">GetRequest</code>, and <code class="literal">KeyNotFoundException</code>.</p><p>The Java messages:</p><div class="informalexample"><pre class="programlisting"><a id="GBS.0087.03"></a>public class SetRequest implements Serializable { public final String key; public final Object value;
    public SetRequest(String key, Object value) { this.key = key; this.value = value; }
}
public class GetRequest implements Serializable { public final String key;
    public GetRequest(String key) { this.key = key; } } public class KeyNotFoundException extends Exception implements Serializable<a id="GBS.0087.04"></a> { public final String key; public KeyNotFoundException(String key) { this.key = key; }
}</pre></div><p>The Scala messages:</p><div class="informalexample"><pre class="programlisting">case class SetRequest(key: String, value: Object) case class GetRequest(key: String) case class KeyNotFoundException(key: String) extends Exception</pre></div><p>These are simple objects. We omit the Java getter as the message is immutable anyway—you can include one if you like.</p><div title="Note" style="" class="note"><div class="inner"><h3 class="title"><a id="tip08"></a>Tip</h3><p>Messages should always<a id="GBS.0087.05"></a> be immutable.</p></div></div><p>(The Scala case class is serializable.)</p></div><div title="Implementing the DB functionality" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"></a>Implementing the DB functionality</h3></div></div></div><p>We&#39;ve covered how to reply to<a id="id215" class="indexterm"></a> messages with <code class="literal">sender() tell/!</code>. We also covered how to reply with <code class="literal">Status.Failure</code>(<code class="literal">Exception</code>). We&#39;ll implement replies to all messages and we&#39;ll also add failure responses if the <code class="literal">GetRequest</code> encounters a miss in the key/value store.</p><p>The Java code&#39;s receive statements:</p><div class="informalexample"><pre class="programlisting">       <a id="GBS.0088.01"></a> receive(ReceiveBuilder. match(SetRequest.class, message -&gt; { log.info(&quot;Received Set request: {}&quot;, message); map.put(message.key, message.value); sender().tell(new Status.Success(message.key), self()); }). match(GetRequest.class, message -&gt; { log.info(&quot;Received Get request: {}&quot;, message);
                            String value = map.get(message.key); Object response = (value != null) ? value : new<a id="GBS.0088.02"></a> Status.Failure(new KeyNotFoundException(message.key)); sender().tell(response, self()); }). matchAny(o -&gt; sender().tell(new Status.Failure(new ClassNotFoundException()), self()) ).build() );</pre></div><p>The Scala code&#39;s <code class="literal">receive</code> method:</p><div class="informalexample"><pre class="programlisting">  override def receive = { case SetRequest(key, value) =&gt; log.info(&quot;received SetRequest - key: {} value: {}&quot;, key, value)
      map.put(key, value) sender() ! Status.Success<a id="GBS.0088.03"></a> case GetRequest(key) =&gt; log.info(&quot;received GetRequest - key: {}&quot;, key) val response: Option[String] = map.get(key) response match{ case Some(x) =&gt; sender() ! x case None =&gt; sender() ! Status.Failure(new KeyNotFoundException(key)) }
    case o =&gt; Status.Failure(new ClassNotFoundException) }</pre></div><p>These are both roughly equivalent, languages aside. If the actor receives a <code class="literal">SetRequest</code>, the actor stores<a id="GBS.0088.04"></a> the value in the map. The behavior has been updated from the first chapter to send back a Success message. For the <code class="literal">GetRequest</code>, the actor tries to retrieve the value from the map. If it&#39;s found, it sends back the value. If it&#39;s not found, the actor sends back a Failure containing the <code class="literal">KeyNotFoundException</code>. Finally, we&#39;ve changed the behavior for unknown messages to reply with a failure—we stuck a <code class="literal"><a id="GBS.0088.05"></a>ClassNotFound</code> exception in, but <a id="id216" class="indexterm"></a>you could make a custom one for greater clarity.</p></div><div title="Enabling remoting" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"></a>Enabling remoting</h3></div></div></div><p>We need to enable remote access<a id="id217" class="indexterm"></a> to the actor from a remote application over <a id="id218" class="indexterm"></a>the network. This is a trivial task fortunately. We need to add the remoting dependency to the <code class="literal">build.sbt</code> file:</p><div class="informalexample"><pre class="programlisting">&quot;com.typesafe.akka&quot; %% &quot;akka-remote&quot; % &quot;2.3.6&quot;</pre></div><p>Then we simply add configuration to enable remote access to our<a id="GBS.0089.01"></a> actor. Add a new file in the <code class="literal">src/main/resources</code> file called <code class="literal">application.conf</code> and put the following configuration in the file with the interface and port to listen on. The <code class="literal">application.conf</code> file is recognized by Akka. It is a <code class="literal">typesafe-config HOCON</code> file, which is a JSON like format that is quite usable relative to other configuration formats&#8212;you&#39;ll see the configuration file referenced in the Akka<a id="GBS.0089.02"></a> documentation often and I personally find the HOCON format is quite a nice alternative to properties files if more than a few properties are needed. Note that properties files are usable as well if desired simply by naming the file <code class="literal">application.properties</code> and using the properties format (for example, <code class="literal">keypath.key=value</code>).Here is the application.conf::</p><div class="informalexample"><pre class="programlisting">akka { actor { provider = &quot;akka.remote.RemoteActorRefProvider&quot;<a id="GBS.0089.03"></a> } remote { enabled-transports = [&quot;akka.remote.netty.tcp&quot;] netty.tcp { hostname = &quot;127.0.0.1&quot; port = 2552 } }
}</pre></div></div><div title="Main" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec24"></a>Main</h3></div></div></div><p>Finally, for the datastore, we need to add <a id="id219" class="indexterm"></a>a main<a id="id220" class="indexterm"></a> method to start the actor system and create the actor.</p><p>In Java, we&#39;ll add a class: <code class="literal">com.akkademy.Main</code>:</p><div class="informalexample"><pre class="programlisting">public class Main { public static void main(String... args) { ActorSystem system = ActorSystem.create(&quot;akkademy&quot;); system.actorOf(Props.create(A<a id="GBS.0089.04"></a>kkademyDb.class), &quot;akkademy-db&quot;); } }</pre></div><p>In Scala, we can put a Main object in the <code class="literal">com.akkademy.AkkademyDb.scala</code> file:</p><div class="informalexample"><pre class="programlisting">object Main extends App { val system = ActorSystem(&quot;akkademy&quot;) system.actorOf(Props[AkkademyDb], name = &quot;akkademy-db&quot;) }</pre></div><p>We simply <a id="id221" class="indexterm"></a>need to create an <code class="literal">ActorSystem</code>, and<a id="id222" class="indexterm"></a> then create the actor in it. Note we give the actor a name—<code class="literal">akkademy-db</code>&#8212;we use a name to be able to easily look up the<a id="GBS.0089.05"></a> actor in the client, and also to ease debugging as Akka will log the Actor&#39;s name in error scenarios.</p></div><div title="Publishing the messages" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"></a>Publishing the messages</h3></div></div></div><p>We need to publish the <a id="id223" class="indexterm"></a>messages locally now so that we can use them in the client project. To publish to Nexus or Artifactory, we would set up the repository information in the <code class="literal">build.sbt</code>, but we&#39;ll simply publish them locally.</p><p>We need to add an organization and version<a id="GBS.0090.01"></a> to the <code class="literal">build.sbt</code> file like the following:</p><div class="informalexample"><pre class="programlisting">name := &quot;akkademy-db&quot;
organization := &quot;com.akkademy-db&quot;
version := &quot;0.0.1-SNAPSHOT&quot;</pre></div><p>&#39;-SNAPSHOT&#39; indicates that the version is unstable and can change. As we will probably republish the server, we should add this tag to the version. If we were to release the code, then we would remove the &#39;-SNAPSHOT&#39; tag from the version to indicate that it will not (and<a id="GBS.0090.02"></a> cannot) change again.</p><p>Lastly, we need to exclude the <code class="literal">application.conf</code> file so that the client doesn&#39;t try to start a remote server. Again, it&#39;s better to put the messages in a standalone library—we&#39;re cutting corners for brevity. Put this in your <code class="literal">build.sbt</code> file to exclude the application.conf when publishing:</p><div class="informalexample"><pre class="programlisting">mappings in (Compile, packageBin) ~= { _.filterNot { case (_, name) =&gt;
  Seq(&quot;application.conf&quot;).contain<a id="GBS.0090.03"></a>s(name)
}}</pre></div><p>If we put the messages in a separate library (and you certainly can), we wouldn&#39;t have needed to exclude the configuration from the build. We&#39;re done with the build configuration. From the command line, in the root of our project, we simply run the activator <code class="literal">publish-local</code> target to publish the project:</p><div class="informalexample"><pre class="programlisting">$activator publish-local</pre></div></div><div title="Starting the DB" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec26"></a>Starting the DB</h3></div></div></div><p>We&#39;re going to build the client<a id="id224" class="indexterm"></a> next,<a id="GBS.0090.04"></a> and to demonstrate integration, we&#39;re going to write some integration tests, so we need the server to be running. We can start the database now:</p><div class="informalexample"><pre class="programlisting">$activator run</pre></div><p>Akka will log that it is listening for remote connections and tells us the address (which we will use shortly in the client):</p><div class="informalexample"><pre class="programlisting">[Remoting] Remoting now listens on addresses: [akka.tcp://akkademy@127.0.0.1:2552]</pre></div></div></div><div title="Producing the client" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"></a>Producing the client</h2></div></div></div><p>We&#39;ve<a id="GBS.0090.05"></a> published <a id="id225" class="indexterm"></a>our messages, and have the key-value store running. We&#39;re ready to wrap up our first distributed application by consuming the service with a client.</p><div title="Scaffolding the project" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec27"></a>Scaffolding the project</h3></div></div></div><p>The first thing we need<a id="id226" class="indexterm"></a> to do is create a project for the client and have it import the server project for the messages. We&#39;ll scaffold the project as we did in <a href="ch01.html" title="Chapter 1. Starting Life as an Actor" class="link">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> &#8212;you can review<a id="GBS.0091.01"></a> the material if needed. Run activator-new and choose minimal-java or minimal-akka project. Call the project <code class="literal">akkademy-db-client</code>.</p></div><div title="Modifying build.sbt" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec28"></a>Modifying build.sbt</h3></div></div></div><p>We need to add the dependency<a id="id227" class="indexterm"></a> for our project into the <code class="literal">build.sbt</code> file. In the new project, add the following dependencies for our messages in <code class="literal">build.sbt</code>:</p><div class="informalexample"><pre class="programlisting">&quot;com.akkademy-db&quot;   %% &quot;akkademy-db&quot;     % &quot;0.0.1-SNAPSHOT&quot;</pre></div><p>Apart from the testing frameworks<a id="GBS.0091.02"></a> included in the scaffolding, this dependency includes the dependencies we need to get going with the Scala project.</p><p>In the Java project, we need to also add the scala-java8-compat library to be able to convert the futures the actor will produce:</p><div class="informalexample"><pre class="programlisting">&quot;org.scala-lang.modules&quot; %% &quot;scala-java8-compat&quot; % &quot;0.6.0&quot;</pre></div></div><div title="Building the client" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec29"></a>Building the client</h3></div></div></div><p>In this section, we&#39;ll <a id="id228" class="indexterm"></a>build the client to connect to the remote actor,<a id="GBS.0091.03"></a> and then implement methods for the <code class="literal">SetRequest</code> and <code class="literal">GetRequest</code> messages.</p><p>First, the Java code can be placed in <code class="literal">com.akkademy.JClient</code>:</p><div class="informalexample"><pre class="programlisting">public class JClient { private final ActorSystem system = ActorSystem.create(&quot;LocalSystem&quot;); private final ActorSelection remoteDb; 
    public JClient(String remoteAddress){ remoteDb = system.actorSelection(&quot;akka.tcp://akkademy@&quot; + remoteAddress + &quot;/user/akkademy-db&quot;);<a id="GBS.0091.04"></a> }
    public CompletionStage set(String key, Object value) { return toJava(ask(remoteDb, new SetRequest(key, value), 2000));}
    public CompletionStage&lt;Object&gt; get(String key){ return toJava(ask(remoteDb, new GetRequest(key), 2000)); }
}</pre></div><p>The Scala code can be placed in <code class="literal">com.akkademy.SClient</code>:</p><div class="informalexample"><pre class="programlisting">class SClient(remoteAddress: String){ private implicit val timeout = Timeout(2 seconds) private implicit<a id="GBS.0091.05"></a> val system = ActorSystem(&quot;LocalSystem&quot;) private val remoteDb = system.actorSelection(s&quot;akka.tcp://akkademy@$remoteAddress/user/akkademy-db&quot;) def set(key: String, value: Object) = { remoteDb ? SetRequest(key, value) }
  def get(key: String) = { remoteDb ? GetRequest(key) }
}</pre></div><p>The code is fairly simple. First, we create a local <code class="literal">ActorSystem</code>, and then get a reference to the remote actor at the address<a id="GBS.0092.01"></a> provided in the constructor. Next, we create a method for each of the behaviors&#8212;get and set. We ask the actor using the messages we imported into our project, and then we return the future. Note we&#39;re using an arbitrary timeout value in the asks. Ideally, the timeout should be configurable.</p><p>For the Java code, we convert the <code class="literal">scala.concurrent.Future</code> to <code class="literal">CompletionStage</code> and return that. This gives<a id="GBS.0092.02"></a> us a better Java API for the consumer of our library to work with.</p><p>Next, to test that it all fits together, we&#39;ll write a small test case.</p></div><div title="Testing" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec30"></a>Testing</h3></div></div></div><p>We need to make sure the <code class="literal">db</code> is running as these are <a id="id229" class="indexterm"></a>integration tests. Here we&#39;ll simply create and then retrieve a record from the remote database.</p><p>The Java example:</p><div class="informalexample"><pre class="programlisting">public class JClientIntegrationTest { JClient client = new JClient(&quot;127.0.0.1:2552&quot;);<a id="GBS.0092.03"></a>
    @Test
    public void itShouldSetRecord() throws Exception { client.set(&quot;123&quot;, 123); Integer result = (Integer) ((CompletableFuture) client.get(&quot;123&quot;)).get(); assert(result == 123); }
}</pre></div><p>And the Scala example:</p><div class="informalexample"><pre class="programlisting">class SClientIntegrationSpec extends FunSpecLike with Matchers { val client = new SClient(&quot;127.0.0.1:2552&quot;)
  describe(&quot;akkademyDbClient&quot;) { it(&quot;should set a value&quot;){ client.set(&quot;123&quot;,<a id="GBS.0092.04"></a> new Integer(123)) val futureResult = client.get(&quot;123&quot;) val result = Await.result(futureResult, 10 seconds) result should equal(123) }
  }
}</pre></div><p>This takes the knowledge we gained about working with Futures to be able to test our API. We use Awaits/get as it&#39;s just a test case, but we now have definitive proof that building distributed applications is feasible with Akka. And we&#39;re only on <a href="ch02.html" title="Chapter 2. Actors and Concurrency" class="link">Chapter2</a>, <span class="emphasis"><em><a id="GBS.0092.05"></a>Actors and Concurrency</em></span>
</p></div></div></div><div style="display:none;"><a id="GBS.0092.06"></a></div></body></html>