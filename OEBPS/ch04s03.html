<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>State</title>
    <link rel="stylesheet" href="epub.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2" />
  </head>
  <body id="page">
    <div style="display:none;">
      <a id="GBS.0139.01"></a>
    </div>
    <div title="State" class="section">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title"><a id="ch04lvl1sec29"></a>State</h1>
          </div>
        </div>
      </div>
      <p>We have looked at how it is <a id="id330" class="indexterm"></a>safe to store state in an Actor—how Actors give us a lock-free way to deal with state in concurrency. We're going to look at how an actor can change its behavior in the face of different states now.</p>
      <p>There are a few mechanisms you can use to change behavior in an actor:</p>
      <div class="itemizedlist">
        <ul class="itemizedlist">
          <li style="list-style-type: disc;" class="listitem">Conditionals based on an Actor's state</li>
          <li style="list-style-type: disc;" class="listitem">Hotswap: <code class="literal">become()</code> and <code class="literal">unbecome()</code></li>
          <li style="list-style-type: disc;" class="listitem">Finite State Machine<a id="GBS.0139.02"></a> (FSM)</li>
        </ul>
      </div>
      <p>We'll look at each after introducing the example that builds on our key-value datastore example.</p>
      <div title="Online/Offline state" class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title"><a id="ch04lvl2sec55"></a>Online/Offline state</h2>
            </div>
          </div>
        </div>
        <p>Let's revisit the first<a id="id331" class="indexterm"></a> fallacy of distributed computing. Not only is the network <a id="id332" class="indexterm"></a>not reliable, but the components that we try to talk<a id="id333" class="indexterm"></a> to over the network could be down. We want our application to handle<a id="id334" class="indexterm"></a> network misses gracefully without dropping too many messages.</p>
        <p>To continue<a id="GBS.0139.03"></a> to develop our database example, we'll improve the remote client so that it deals with network partitions such as temporary failure of network components or database service restarts as gracefully as possible in the case of a client-server model.</p>
        <p>What we looked at in <a href="ch02.html" title="Chapter 2. Actors and Concurrency" class="link">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> was an example where we had a remote key-value datastore, which we connected to from a client.<a id="GBS.0139.04"></a> We did an <code class="literal">actorSelection</code> to get a reference to the remote actor and then started sending it messages. What if the database isn't ready when we start our application? Or, what if the database goes offline for a moment?</p>
        <div title="Transitioning state" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec50"></a>Transitioning state</h3>
              </div>
            </div>
          </div>
          <p>One of the most common<a id="id335" class="indexterm"></a> examples I have seen of the use of state is to determine if a service is online or offline. We examined this in the section on failure,<a id="GBS.0139.05"></a> and looking at what happens to actors when they restart. We'll continue with the example of a database client actor connecting to a remote database.</p>
        </div>
        <div title="Stashing messages between states" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec51"></a>Stashing messages between states</h3>
              </div>
            </div>
          </div>
          <p>If the bartender <a id="id336" class="indexterm"></a>at<a id="id337" class="indexterm"></a> our sushi restaurant gets a request to pour a beer while the keg is being changed, he won't be able to take care of that order. But he will be able to at a later point in time, once the new keg<a id="GBS.0140.01"></a> is ready. The bartender won't simply throw away the order because the keg isn't ready—he will set aside the order for a minute and process other orders that he is able to (like pouring more sake for the chef). Once the keg is ready, then he'll put any beer orders back in his queue to process.</p>
          <p>Similar to this <a id="id338" class="indexterm"></a>example, it's very common for an Actor to be in a state where it can't process certain<a id="GBS.0140.02"></a> messages. If the database client is offline, it isn't <a id="id339" class="indexterm"></a>going to be able to handle any messages until it is online. We could have the client connection continue to restart until it connects, in which case it will drop every message it encounters until it's able to connect successfully. Or we could have the client set the messages it cannot handle aside while waiting for the client to enter a connected<a id="GBS.0140.03"></a> state.</p>
          <p>Akka has a mechanism called <code class="literal">stash</code> to do this. Stashing messages puts the message off to the side in a separate queue that it cannot currently handle:</p>
          <div class="informalexample">
            <pre class="programlisting">if(cantHandleMessage){ stash(); }else{ handleMessage(message); }</pre>
          </div>
          <p>Unstash puts the messages that were set aside back into the mailbox queue for the actor to handle.</p>
          <div class="informalexample">
            <pre class="programlisting">changeStateToOnline(); unstash();

To use stash in Java, your Actor will extend<a id="GBS.0140.04"></a> AbstractActorWithStash:
class RemoteActorProxy extends AbstractActorWithStash { [...] }
To use stash in Scala, you mix in the stash trait:
class RemoteActorProxy extends Actor with Stash { [...] }</pre>
          </div>
          <p>We'll use this mechanism now to demonstrate how to make a client switch between online and offline states.</p>
          <div title="Note" style="" class="note">
            <div class="inner">
              <h3 class="title"><a id="note02"></a>Note</h3>
              <p>NOTE that <code class="literal">stash()</code> and <code class="literal">unstash()</code> can be handy when you expect state to change quickly, but<a id="GBS.0140.05"></a> states where messages are stashed should always be time-bound or else you risk flooding your mailboxes.</p>
            </div>
          </div>
        </div>
      </div>
      <div title="Conditional statements" class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title"><a id="ch04lvl2sec56"></a>Conditional statements</h2>
            </div>
          </div>
        </div>
        <p>The most naive approach is<a id="id340" class="indexterm"></a> to store state in the actor and then have a conditional statement decide what behavior the actor should take.</p>
        <p>You can store a Boolean to say if you're connected to the database, and if you're connected, try to handle the message. If you're<a id="GBS.0141.01"></a> not, you can fail.</p>
        <p>The following is a Java example of storing state and handling behavior with conditional statements:</p>
        <div class="informalexample">
          <pre class="programlisting">private Boolean online = false; public PartialFunction receive() { return RecieveBuilder. match(GetRequest.class, x -&gt; { if(online) { processMessage(x); } else { stash(); } }). match(Connected.class, x -&gt; { online = true; unstash(); ). match(Disconnected.class, x -&gt; online = false).<a id="GBS.0141.02"></a> build(); 
Here is the Scala equivalent to storing state and changing behavior with conditionals:
 var online = false def receive = { case x: GetRequest =&gt; if(online) processMessage(x) else stash() case _: Connected =&gt; online = true unstash() case _: Disconnected =&gt; online = false }</pre>
        </div>
        <p>This conditional statement is the most basic way to express different behavior based on state stored in an actor.<a id="GBS.0141.03"></a> We store a Boolean called <code class="literal">online</code> that represents if the actor is connected or not. If the actor is connected, it processes the message. If it is not connected, it stashes the messages, as covered previously. If it receives a Connected message, then it changes its state to be online and unstashes all of the messages. Because of the use of <code class="literal">stash</code>/<code class="literal">unstash</code>, once it comes online, the actor will then<a id="GBS.0141.04"></a> process any messages it stashed.</p>
        <p>It's very common for an actor to store state and behave differently depending on that state. Using conditionals is a very procedural approach to dealing with behavior and state. Fortunately, Akka<a id="id341" class="indexterm"></a> gives us a couple of better options.</p>
      </div>
      <div title="Hotswap: Become/Unbecome" class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title"><a id="ch04lvl2sec57"></a>Hotswap: Become/Unbecome</h2>
            </div>
          </div>
        </div>
        <p>The code with <a id="id342" class="indexterm"></a>conditionals was not very pretty. It certainly was not very <a id="id343" class="indexterm"></a>declarative. Akka gives us <code class="literal"><a id="GBS.0141.05"></a>become()</code> and <code class="literal">unbecome()</code> to manage behavior that can improve the clarity of the code considerably. In the actor's <code class="literal">context()</code>, there are a two methods:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li style="list-style-type: disc;" class="listitem"><code class="literal">become(PartialFunction behavior)</code>: This changes the actor's behavior from the behavior defined in the receive block to a new <code class="literal">PartialFunction</code>.</li>
            <li style="list-style-type: disc;" class="listitem"><code class="literal">unbecome()</code>: This reverts the actor's behavior back to the default behavior.</li>
          </ul>
        </div>
        <p>Let's look at how using this mechanism<a id="GBS.0142.01"></a> can improve our previous example:</p>
        <div class="informalexample">
          <pre class="programlisting">public PartialFunction receive() { return RecieveBuilder. match(GetRequest.class, x -&gt; stash()). match(Connected.class, x -&gt; { context().become(online); unstash(); }). build(); } final private PartialFunction&lt;Object, BoxedUnit&gt; online(final ActorRef another) { return RecieveBuilder. match(GetRequest.class, x -&gt; processMessage(x)). build(); }</pre>
        </div>
        <p>Here is the Scala<a id="GBS.0142.02"></a> equivalent:</p>
        <div class="informalexample">
          <pre class="programlisting">  def receive = { case x: GetRequest =&gt; stash() case _: Connected =&gt; become(online) unstash() } def online: Receive = { case x: GetRequest =&gt; processMessage(x) case _: Disconnected =&gt; unbecome() }</pre>
        </div>
        <p>This has better readability than conditional statements. Each state's behavior is described in its own <code class="literal">PartialFunction</code> where pattern matching and behavior are described. This lets us read<a id="GBS.0142.03"></a> the behavior of the actor in its different states independently.</p>
        <p>The actor starts in the offline state where it will stash messages it is not able to respond to <code class="literal">(GetRequest)</code>. Those messages get set aside until the <code class="literal">Connected</code> message is received. Once the Connected message is received, then the actor calls become to change its behavior to the online state described in the online method. At this<a id="GBS.0142.04"></a> time, the actor also calls <code class="literal">unstash</code> to put the messages set aside, back into the queue. Now all of the messages will be processed with the new behavior.</p>
        <p>If the actor receives a <code class="literal">Disconnected</code> message, then it calls <code class="literal">unbecome</code>, which will revert the actor to its default behavior. Note that any number of receive blocks can be defined and swapped between. Hotswap can handle mostly any behavior changes<a id="GBS.0142.05"></a> that might need to be handled in an actor as it changes behavior. This is a nice easy abstraction for producing readable actors.</p>
        <div title="Stash leaks" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec52"></a>Stash leaks</h3>
              </div>
            </div>
          </div>
          <p>The examples covered so far <a id="id344" class="indexterm"></a>using stash have a problem—if the connect message takes too long to be received, or is not received, then messages will continually be stashed until the application runs out of memory or the mailbox starts dropping messages (mailboxes<a id="GBS.0143.01"></a> are covered further in a later chapter). Wherever using <code class="literal">stash()</code>, it's a good idea to put a boundary on how much time can pass or how many messages can be received before taking action.</p>
          <p>The most basic way to do this is to schedule a timeout message to be sent to the actor after a certain period of time.</p>
          <p>We can schedule one message in the actor's constructor or <code class="literal">postStart </code>hook, and then when it is<a id="GBS.0143.02"></a> received, check that the actor is connected. If it's not connected, then the actor can escalate the problem and have the supervisor take action:</p>
          <div class="informalexample">
            <pre class="programlisting">system.scheduler().scheduleOnce(Duration.create(1000, TimeUnit.MILLISECONDS), self(), CheckConnected, system.dispatcher(), null);</pre>
          </div>
          <p>If the actor receives the message and it is online, it will be ignored. If the actor receives the message and it is not online,<a id="GBS.0143.03"></a> then it will throw an exception:</p>
          <div class="informalexample">
            <pre class="programlisting"> .match(CheckConnected.class, msg -&gt; throw new ConnectTimeoutException())
case _: CheckConnected =&gt; throw new ConnectTimeoutException</pre>
          </div>
        </div>
        <div title="Finite State Machines (FSM)" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec53"></a>Finite State Machines (FSM)</h3>
              </div>
            </div>
          </div>
          <p>There is another tool for handling state in <a id="id345" class="indexterm"></a>actors: <span class="strong"><strong>Finite State Machine </strong></span>(<span class="strong"><strong>FSM</strong></span>). Much like hotswap, FSMs have state and behavior that changes based on state. FSM is a bit heavier of an abstraction than<a id="GBS.0143.04"></a> hotswap and requires more code and types to get up and running, so hotswap will usually be a simpler and more readable option.</p>
          <p>We have a good example for connected/disconnected to use in the client—we'll keep that in place for the basic client and look for other ways we can improve the client/server communication.</p>
          <p>The Fallacies of Distributed Computing were introduced earlier in this chapter.<a id="GBS.0143.05"></a> One of the points is that there is a cost in latency for every request and response over the network (fallacy: latency is zero). Because there is a cost to every request and response, reducing the number of times messages are sent and responded to can cut down on total time spent waiting. To improve our client and server behavior, we can reduce how many messages are sent over the network by combining<a id="GBS.0144.01"></a> them into a smaller number of requests.</p>
          <p>Using traditional request/response protocols, an application will make a request over the network and then wait for the response to continue processing messages. In an application where we need to read multiple records from a database, the typical flow may look something like the following:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem"><span class="strong"><strong>Client</strong></span>: Send <code class="literal">GetRequest(user)</code> over network.</li>
              <li class="listitem"><span class="strong"><strong>Server</strong></span>: Reply to client<a id="GBS.0144.02"></a> with user data.</li>
              <li class="listitem"><span class="strong"><strong>Client</strong></span>: Wait for <code class="literal">Success</code> response.</li>
              <li class="listitem"><span class="strong"><strong>Client</strong></span>: Send <code class="literal">GetRequest</code>(article) to server.</li>
              <li class="listitem"><span class="strong"><strong>Server</strong></span>: Reply to client with article data.</li>
              <li class="listitem"><span class="strong"><strong>Client</strong></span>: Wait for Success response.</li>
              <li class="listitem"><span class="strong"><strong>Client</strong></span>: Return Success response to create user profile request</li>
            </ol>
          </div>
          <p>The time taken for a signal to be sent plus the acknowledgment to be received is called <a id="id346" class="indexterm"></a>
<span class="strong"><strong>Round-trip Delay Time</strong></span> (<span class="strong"><strong>RTD</strong></span> or <span class="strong"><strong>RTT</strong></span>). One of the Reactive Tenets is to be responsive<a id="GBS.0144.03"></a> to our users, so we want to eliminate the amount of time we spend waiting for messages to travel over the network.</p>
          <p>One way we can improve our datastore API is to allow the datastore to accept a list. This would let us send multiple operations in a single request:</p>
          <div class="informalexample">
            <pre class="programlisting">ask(remoteActorSelection, Arrays.asList( new SetRequest(id, user, sender), new SetRequest("profile-" + id, profile, sender)), timeout);<a id="GBS.0144.04"></a> remoteActorSelection ? List( SetRequest(id, user, sender), SetRequest("profile-"+id, profile, sender) )</pre>
          </div>
          <p>Note that on the preceding snippet showing the list, we've included a sender in the messages to allow us to complete futures or reply to Actors.</p>
          <p>Trying to create a single list in an application request could prove to be inconvenient to the users of our library. We can improve the client API<a id="GBS.0144.05"></a> to handle this concern.</p>
          <p>We'll create an actor <a id="id347" class="indexterm"></a>to use in our datastore client that sends messages to a remote database actor once several messages have accumulated or once a <code class="literal">Flush</code> message is received. By doing this, we put the concern of gathering and sending messages in one actor to adhere to single responsibility principle. (Note that this example is similar to the one in the Akka documentation<a id="GBS.0145.01"></a> for FSM—you can see the documentation if you need a quick reference or want to see a different implementation.)</p>
          <p>The FSM types have two parameters: State and Container. We'll look at defining those and then we'll look at building the FSM.</p>
        </div>
        <div title="Defining states" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec54"></a>Defining states</h3>
              </div>
            </div>
          </div>
          <p>The FSM <a id="id348" class="indexterm"></a>describes its state a bit differently than other actors we have looked at.</p>
          <p>For our FSMs, we will improve on the hotswap example to<a id="GBS.0145.02"></a> store messages in the actor instead of stashing them:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Disconnected</strong></span>: Not online and no messages are queued</li>
              <li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Disconnected and Pending</strong></span>: Not online and messages are queued</li>
              <li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Connected</strong></span>: Online and no messages are queued</li>
              <li style="list-style-type: disc;" class="listitem">C<span class="strong"><strong>onnected and Pending</strong></span>: Online and Messages are Pending</li>
            </ul>
          </div>
          <p>We use an <code class="literal">enum</code> in Java for the states:</p>
          <div class="informalexample">
            <pre class="programlisting">enum State{ DISCONNECTED, CONNECTED, CONNECTED_AND_PENDING, }</pre>
          </div>
          <p>In Scala, we can use case objects<a id="GBS.0145.03"></a> instead:</p>
          <div class="informalexample">
            <pre class="programlisting">sealed trait State case object Disconnected extends State case object Connected extends State case object ConnectedAndPending extends State</pre>
          </div>
        </div>
        <div title="Defining the state container" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec55"></a>Defining the state container</h3>
              </div>
            </div>
          </div>
          <p>We've described the states, now <a id="id349" class="indexterm"></a>we need to define the state container for the actor. The state container is where we will store the messages. The FSM allows us to define the state container and change it between states,<a id="GBS.0145.04"></a> so our use case maps quite nicely to the FSM as we'll change the state container when we change between states.</p>
          <p>For our state container, we'll store a list of requests to be processed on a flush event:</p>
          <div class="informalexample">
            <pre class="programlisting">public class EventQueue extends LinkedList&lt;Request&gt; {}</pre>
          </div>
          <p>In Scala, we'll use a type definition for this purpose:</p>
          <div class="informalexample">
            <pre class="programlisting">object StateContainerTypes { type RequestQueue = List[Request] }
public class Flush<a id="GBS.0145.05"></a> {}
case object Flush</pre>
          </div>
          <p>Now we're ready to build the actor's behavior.</p>
        </div>
        <div title="Defining behavior in FSMs" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="ch04lvl3sec56"></a>Defining behavior in FSMs</h3>
              </div>
            </div>
          </div>
          <p>First, FSMs <a id="id350" class="indexterm"></a>must extend the base traits.</p>
          <p>In Java8, we <a id="id351" class="indexterm"></a>extend <code class="literal">akka.actor.AbstractFSM&lt;S, D&gt;</code>
</p>
          <div class="informalexample">
            <pre class="programlisting">public class BunchingAkkademyClient extends AbstractFSM&lt;State, RequestQueue&gt;{ {//init block } }</pre>
          </div>
          <p>Note that we create an init block—we describe the behavior in this init block.</p>
          <p>In Scala, we extend <code class="literal">akka.actor.FSM[S,<a id="GBS.0146.01"></a> D]</code>:</p>
          <div class="informalexample">
            <pre class="programlisting">class BunchingAkkademyClient extends FSM[State, RequestQueue]{ }</pre>
          </div>
          <p>In the actors, we can now use the FSM API to describe the behavior in different states. First, we call the <code class="literal">startWith</code> method to describe how the actor starts:</p>
          <div class="informalexample">
            <pre class="programlisting">{ startWith(DISCONNECTED, null); }
  startWith(Disconnected, null) //scala needs no init block!</pre>
          </div>
          <p>Then we describe how different messages are responded to in different states<a id="GBS.0146.02"></a> and how the state changes depending on the message. There are a few ways to describe the behavior. The one that you'll be most comfortable with is calling <code class="literal">when</code> (S state, <code class="literal">PartialFunction pf</code>). We can build the behavior for each case by calling the <code class="literal">when</code> statement several times.</p>
          <p>In Java, we can build a partial function again using tools that Akka gives us similar to the <code class="literal">ReceiveBuilder</code>.</p>
          <p>We'll describe<a id="GBS.0146.03"></a> each of the<a id="id352" class="indexterm"></a> states and the response to<a id="id353" class="indexterm"></a> Flush, Connected, and Request messages:</p>
          <div class="informalexample">
            <pre class="programlisting">        when(DISCONNECTED, matchEvent(FlushMsg.class, (msg, container) -&gt; stay()) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return stay(); }).event(Tcp.Connected.class, (msg, container) -&gt; { if(container.getFirst() == null){ return goTo(CONNECTED); }else{ return goTo(CONNECTED_AND_PENDING);<a id="GBS.0146.04"></a> } })); when(CONNECTED, matchEvent(FlushMsg.class, (msg, container) -&gt; stay()) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return goTo(CONNECTED_AND_PENDING); })); when(CONNECTED_AND_PENDING, matchEvent(FlushMsg.class, (msg, container) -&gt; { container = new EventQueue(); return stay(); }) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return goTo(CONNECTED_AND_PENDING);<a id="GBS.0146.05"></a> })); 
         scala.PartialFunction pf = ReceiveBuilder.match(String.class, x -&gt; System.out.println(x)).build(); when(CONNECTED, pf);</pre>
          </div>
          <p>And for Scala, we use pattern matching to describe the <code class="literal">PartialFunction</code> in each state with <code class="literal">when</code>(state):</p>
          <div class="informalexample">
            <pre class="programlisting">  when(Disconnected){ case (_: Connected, container: RequestQueue) =&gt; if (container.headOption.isEmpty) goto(Connected) else goto(ConnectedAndPending) case (x:<a id="GBS.0147.01"></a> GetRequest, container: RequestQueue) =&gt; stay using(container :+ x) } when (Connected) { case (x: GetRequest, container: RequestQueue) =&gt; goto(ConnectedAndPending) using(container :+ x) } when (ConnectedAndPending) { case (Flush, container) =&gt; remoteDb ! container; container = Nil goto(Connected) case (x: GetRequest, container: RequestQueue) =&gt; stay using(container :+ x) }</pre>
          </div>
          <p>In Both the Java and<a id="GBS.0147.02"></a> Scala examples, we describe the three states. The <code class="literal">Disconnected</code> state will store messages or go online. It will ignore messages other than <code class="literal">Connected</code> or <code class="literal">GetRequest</code>.</p>
          <p>In the <code class="literal">Connected</code> state, we<a id="id354" class="indexterm"></a> only care about messages<a id="id355" class="indexterm"></a> that make us transition to the <code class="literal">ConnectedAndPending</code> state.</p>
          <p>Finally, the <code class="literal">ConnectedAndPending</code> state can either flush or add a request to the container. In Scala, the container is an immutable<a id="GBS.0147.03"></a> type, so we pass a new container through the state changes.</p>
          <p>Note that we ignore messages in some states or process them in others. We'll ignore the Flush command if there are no messages to flush, but we'll process it and move back to the <code class="literal">Connected</code> state with no pending messages after a flush.</p>
          <p>The actor has to return a description of states that it either stays in or moves to in the FSM, which<a id="GBS.0147.04"></a> means that, compared to hotswap, the FSM requires a more descriptive actor. There is some boilerplate to using FSM, but it can produce clearer actor code in some cases. It's possible to use either hotswap or FSM for actor with different behavior in states. You can evaluate which will produce more usable code for your use case. FSM is another tool in your toolbelt—in many cases, hotswap will be enough<a id="GBS.0147.05"></a> and simpler, but FSMs might have maintainability benefits in some cases.</p>
          <p>The last thing we do in the block is call <code class="literal">initialize()</code>:</p>
          <div class="informalexample">
            <pre class="programlisting">initialize();</pre>
          </div>
        </div>
      </div>
      <div title="Using restarts to transition through states" class="section">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title"><a id="ch04lvl2sec58"></a>Using restarts to transition through states</h2>
            </div>
          </div>
        </div>
        <p>Note that the <a id="id356" class="indexterm"></a>actor does not have any disconnect message or behavior. If we encounter an exception in our actor's state, the easiest way to transition back to disconnected is to simply throw an exception and<a id="GBS.0148.01"></a> have the actor restart. Very often this will be the simplest and most reliable way to respond to an exceptional case. Once your actor is running, do not be afraid to restart your actors! You know that the piece of the actor system that is encountering the problem will simply be recreated. The Akka team's blog is called "Let IT Crash" because of the attitude that Akka takes to the reliability of<a id="GBS.0148.02"></a> our software. If an exception is thrown, Akka takes care of it for us by recreating the piece of our software that fails.</p>
        <p>The best way to handle understanding if the actor is connected is to get a message from the remote actor every couple of seconds. This is called a "heartbeat." We could build a heartbeat that checks that the actor is responding, and, if it is not, then we could restart the<a id="GBS.0148.03"></a> actor and log the exception. In our FSM example, if we restarted after a couple of missed heartbeats, the actor would dump any pending messages, which, while it would drop them, would mean that the application wouldn't leak too much memory. When the remote database finally becomes available, then the application will resume behavior as normal.</p>
      </div>
    </div>
    <div style="display:none;">
      <a id="GBS.0148.04"></a>
    </div>
  </body>
</html>
