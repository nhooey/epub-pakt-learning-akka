<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Chapter 9. A Journey's End</title>
    <link rel="stylesheet" href="epub.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2" />
  </head>
  <body id="page">
    <div style="display:none;">
      <a id="GBS.0255.01"></a>
    </div>
    <div title="Chapter 9. A Journey's End" class="chapter">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title"><a id="ch09"></a>Chapter 9. A Journey's End</h1>
          </div>
        </div>
      </div>
      <p>You have made it to the Journey's end. You are now armed with a bit of knowledge about building concurrent and distributed systems with Akka and Scala or Java8.</p>
      <p>I expect a wide variety of readers to be here—some with distributed computing experience, and some with none. Either way, the material requires practice to master. </p>
      <p>The Akka toolkit is quite large and the documentation<a id="GBS.0255.02"></a> is a very thorough and useful reference to all of its parts. This book has hopefully showed you why and when to use many of Akka's different tools. This chapter will highlight a few outstanding features and modules that you may want to be aware of, and some next steps, as follows:</p>
      <div class="itemizedlist">
        <ul class="itemizedlist">
          <li style="list-style-type: disc;" class="listitem">Other Akka features and modules:<div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Logging</li><li style="list-style-type: disc;" class="listitem">Event Bus</li><li style="list-style-type: disc;" class="listitem">Agents</li><li style="list-style-type: disc;" class="listitem">Akka Persistence</li><li style="list-style-type: disc;" class="listitem">Akka I/O</li><li style="list-style-type: disc;" class="listitem">Akka Streams and Akka HTTP</li></ul></div></li>
          <li style="list-style-type: disc;" class="listitem">Next steps:<div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem"><a id="GBS.0255.03"></a>Learning about Domain Driven Design</li><li style="list-style-type: disc;" class="listitem">Deployment tools</li><li style="list-style-type: disc;" class="listitem">Monitoring logs and events</li></ul></div></li>
        </ul>
      </div>
      <div title="Other Akka Features and Modules" class="section">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec60"></a>Other Akka Features and Modules</h1>
            </div>
          </div>
        </div>
        <p>From the<a id="id574" class="indexterm"></a> outset, this book has said that it will not cover every last corner of the Akka toolkit, but instead focus on helping you learn about distributed computing using Akka. Akka is quite a large tool kit, and all of the most important core pieces have been well covered.</p>
        <p>Now that<a id="GBS.0255.04"></a> we're at the end of our journey here, it's a good time to highlight a few areas of the toolkit that you might want to take a look at in more depth. I'll give a brief introduction to them here so you're aware of some of the interesting extensions.</p>
        <div title="Logging in Akka" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec94"></a>Logging in Akka</h2>
              </div>
            </div>
          </div>
          <p>We briefly <a id="id575" class="indexterm"></a>introduced logging <a id="id576" class="indexterm"></a>in Akka early in the book, but we'll review logging again here briefly to show how to use more advanced<a id="GBS.0255.05"></a> features. Akka by default will log to the console; however, it offers an event handler for <code class="literal">slf4j</code> that is available by importing an slf4j backend into your project such as <code class="literal">Logback</code>.</p>
          <p>To use the <code class="literal">slf4j</code> logger, you'll need to provide the Akka <code class="literal">slf4j</code> module (it's not in the Akka core), and you'll also need to provide an <code class="literal">slf4j</code> backend such as <code class="literal">Logback</code>. You can add these dependencies to your <code class="literal">build.sbt</code> file<a id="GBS.0256.01"></a> using the following code:</p>
          <div class="informalexample">
            <pre class="programlisting">"ch.qos.logback" % "logback-classic" % "1.0.0" % "runtime",
"com.typesafe.akka" %% "akka-slf4j" % "2.3.11"</pre>
          </div>
          <p>Then, in your application configuration (the <code class="literal">application.conf file</code>), you can declare the Akka <code class="literal">slf4j</code> event handler to be used as follows:</p>
          <div class="informalexample">
            <pre class="programlisting">akka {
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]
loglevel = "DEBUG"
}</pre>
          </div>
          <p>You can put a <code class="literal">logback.xml</code> file into your<a id="GBS.0256.02"></a> project's resources folder to enable fine-grained log control and more extended control over appenders. If you wanted to log to both a file (<code class="literal">logs/app.log</code>) and the console, a basic configuration will look like this:</p>
          <div class="informalexample">
            <pre class="programlisting">&lt;configuration&gt;
&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
&lt;file&gt;logs/app.log&lt;/file&gt;

&lt;encoder&gt;
&lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;<a id="GBS.0256.03"></a>
&lt;/encoder&gt;
&lt;/appender&gt;

&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
&lt;encoder&gt;
&lt;pattern&gt;%msg%n&lt;/pattern&gt;
&lt;/encoder&gt;
&lt;/appender&gt;

&lt;root level="debug"&gt;
&lt;appender-ref ref="FILE" /&gt;
&lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
&lt;/configuration&gt;</pre>
          </div>
          <p>To use<a id="id577" class="indexterm"></a> Akka<a id="id578" class="indexterm"></a> logging in the application, you can either create a logger explicitly, passing in an <code class="literal">ActorSystem</code> object:</p>
          <div class="informalexample">
            <pre class="programlisting">//java
LoggingAdapter<a id="GBS.0256.04"></a> log = Logging.getLogger(getContext().system(), this);

//scala
val log = Logging(context.system, this)</pre>
          </div>
          <p>Or, if using Scala, you can mix in the logging trait into your actor:</p>
          <div class="informalexample">
            <pre class="programlisting">class MyActor extends Actor with akka.actor.ActorLogging {
  log.info("actor startup: {}", self.toString)
}</pre>
          </div>
          <p>Note that Akka will accept a variable length argument list as parameters in the messages, where it will replace each<a id="GBS.0256.05"></a> pair of brackets,{}, with the parameters in the order they are provided. Exceptions can be logged by passing them as the first argument:</p>
          <div class="informalexample">
            <pre class="programlisting">#+BEGIN_SRC
//java
log.debug("params {} {} {}", param1, param2, param3);
log.error(e, "exception encountered: "); //exceptions are first arg

//scala
log.debug("params {} {} {}", param1, param2, param3)
log.info(e, "exception encountered: ") //exceptions are<a id="GBS.0257.01"></a> first arg
#+END_SRC</pre>
          </div>
          <p>There are performance benefits to letting logger handle the string interpolation, as it will execute the interpolation only if the log level is set so that the logger will actually log the event. If the event is not logged, then the string interpolation will not occur. Thus, this is generally better than doing something such as this:</p>
          <div class="informalexample">
            <pre class="programlisting">#+BEGIN_SRC
log.debug("this actor is " +<a id="GBS.0257.02"></a> self().toString);
#+END_SRC</pre>
          </div>
          <p>The preceding code will always create the joined string in memory, even if the message is never logged.</p>
          <p>This covers <a id="id579" class="indexterm"></a>almost everything you'll need to know about logging in <a id="id580" class="indexterm"></a>Akka. For additional information on configuring logging, you will want to check the <code class="literal">Logback</code> documentation. Rolling log files, multiple appenders, and other advanced features can be handled by configuring<a id="GBS.0257.03"></a> <code class="literal">Logback</code>, especially using <code class="literal">logback.xml</code>. For very advanced use cases, <code class="literal">Logback</code> also supports configurations written in the groovy programming language.</p>
        </div>
        <div title="Message Channels and EventBus" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec95"></a>Message Channels and EventBus</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">EventBus</code> object <a id="id581" class="indexterm"></a>in Akka can be used to publish and subscribe to events to <a id="id582" class="indexterm"></a>send messages to <a id="id583" class="indexterm"></a>multiple actors. Pub/Sub approaches <a id="id584" class="indexterm"></a>can be built with very little code by sending subscribe messages to an actor that will<a id="GBS.0257.04"></a> in turn hold a list of actors. However, Akka also describes a mechanism to handle this, where you listen for a topic.</p>
          <p>Eventbus is a part of the core Akka library, so no extra imports are required.</p>
          <p>Using an event bus requires choosing and extending a classifier that will describe the event type and how to target subscribers. Classifiers are described in the documentation referenced at the end of<a id="GBS.0257.05"></a> this section.</p>
          <p>IRemember you can always use actor hierarchies to send messages with actorSelection as well. Event Bus should come to mind if you have very specific topic subscription to handle that hierarchies are not suitable for.</p>
          <p>To use the event bus, there are three types that we're concerned with foremost and that we'll declare as types in Scala, or define with type arguments in Java, as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li style="list-style-type: disc;" class="listitem"><span class="strong"><strong><a id="GBS.0258.01"></a>Classifier Type</strong></span>: what the topic type is for the message</li>
              <li style="list-style-type: disc;" class="listitem"><span class="strong"><strong>Event Type</strong></span>: what data type is provided on the publish event:<div class="itemizedlist"><ul class="itemizedlist"><li style="list-style-type: disc;" class="listitem">Needs a topic (you'll define the logic for the topic)</li><li style="list-style-type: disc;" class="listitem">Optionally needs some other data to publish</li></ul></div></li>
              <li style="list-style-type: disc;" class="listitem">
                <span class="strong">
                  <strong>Subscriber Type</strong>
                </span>
              </li>
            </ul>
          </div>
          <p>Multiple Classifiers are available. As a quick example, assume we have a message called <code class="literal">EventBusMessage</code>, and we want to use the Event Bus to have actors subscribe and publish<a id="GBS.0258.02"></a> to them. The event bus doesn't need to use actors—it can implement any pub/sub behavior you require. A simple <code class="literal">LookupClassifier</code> object will describe the type of the event, the topic/classifier type, and how to lookup the classification of the topic for subscribers. In the case of <code class="literal">LookupClassifier</code>, the subscribers need to have an ordering.</p>
          <p>A simple <a id="id585" class="indexterm"></a>Java message <a id="id586" class="indexterm"></a>might look<a id="id587" class="indexterm"></a> like<a id="id588" class="indexterm"></a> this:</p>
          <div class="informalexample">
            <pre class="programlisting">public class<a id="GBS.0258.03"></a> EventBusMessage {
    public final String topic;
    public final String msg;

    public EventBusMessage(String topic, String msg) {
this.topic = topic;
        this.msg = msg;
    }
}</pre>
          </div>
          <p>The following are the Java and Scala event bus examples:</p>
          <div class="informalexample">
            <pre class="programlisting">public class JavaLookupClassifier extends LookupEventBus&lt;EventBusMessage, ActorRef, String&gt; {

    @Override public String classify(EventBusMessage event)<a id="GBS.0258.04"></a> {
        return event.topic;
    }

    @Override public void publish(EventBusMessage event, ActorRef subscriber) {
subscriber.tell(event.msg, ActorRef.noSender());
    }

    @Override public int compareSubscribers(ActorRef a, ActorRef b) {
        return a.compareTo(b);
    }

    // determines the initial size of the index data structure
    @Override public intmapSize() {
        return 128;<a id="GBS.0258.05"></a>
    }
}

class ScalaLookupClassifier extends EventBus with LookupClassification {
    type Event = EventBusMessage
    type Classifier = String
    type Subscriber = ActorRef

    override protected def classify(event: Event): Classifier = event.topic

    override protected def publish(event: Event, subscriber: Subscriber): Unit = {
      subscriber ! event.msg
    }

    override protected def<a id="GBS.0259.01"></a> compareSubscribers(a: Subscriber, b: Subscriber): Int =
a.compareTo(b)

    //initial size of the index data structure
    override protected defmapSize: Int = 128
}</pre>
          </div>
          <p>The preceding<a id="id589" class="indexterm"></a> code implements some pretty basic logic such as how to<a id="id590" class="indexterm"></a> determine the topic, what to do with<a id="id591" class="indexterm"></a> a publish event for any relevant<a id="id592" class="indexterm"></a> subscribers, and a requirement—how to compare subscribers. Also, the beginning size for the<a id="GBS.0259.02"></a> map needs to be declared, although it will adjust automatically as needed.</p>
          <p>You might use it like this:</p>
          <div class="informalexample">
            <pre class="programlisting">JavaLookupClassifier lookupBus = new JavaLookupClassifier;
lookupBus.subscribe(myActor, "greetings");
lookupBus.publish(new EventBusMessage("time", System.currentTimeMillis().toString));
lookupBus.publish(new EventBusMessage("greetings", "hello"));

val lookupBus = new JavaLookupClassifier
lookupBus.subscribe(m<a id="GBS.0259.03"></a>yActor, "greetings")
lookupBus.publish(new EventBusMessage("time", System.currentTimeMillis().toString))
lookupBus.publish(new EventBusMessage("greetings", "hello"))</pre>
          </div>
          <p>In this case, our actor subscribes to the topic greetings. Then, we publish an event with the topic time and the topic greetings. As you can probably guess, the only message that gets to the actor will be the one sent with the topic<a id="GBS.0259.04"></a> "greetings."</p>
          <p>The Akka documentation has examples and explanation for the classifiers if you want to further explore using <a id="id593" class="indexterm"></a>Akka's Event Bus features. The Akka documentation can be found here:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li style="list-style-type: disc;" class="listitem">
                <a href="http://doc.akka.io/docs/akka/snapshot/java/event-bus.html" class="ulink">http://doc.akka.io/docs/akka/snapshot/java/event-bus.html</a>
              </li>
              <li style="list-style-type: disc;" class="listitem">
                <a href="http://doc.akka.io/docs/akka/snapshot/scala/event-bus.html" class="ulink">http://doc.akka.io/docs/akka/snapshot/scala/event-bus.html</a>
              </li>
            </ul>
          </div>
        </div>
        <div title="Agents" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec96"></a>Agents</h2>
              </div>
            </div>
          </div>
          <p>The Akka Agent module <a id="id594" class="indexterm"></a>is inspired by Clojure's Agents, which are reactive<a id="id595" class="indexterm"></a> constructs<a id="GBS.0259.05"></a> to help handle shared access to state. A better way to think about the Agent is much like a Java <code class="literal">AtomicInteger</code>, but for any value or type. It holds that state, and allows you to execute atomic operations on the value stored in a thread-safe manner, while allowing access to read the value safely.</p>
          <p>More formally put, Agents provide a single storage location for a single value and allow modification<a id="GBS.0260.01"></a> of that value by providing a function. Agents allow safe atomic and transactional access to their value, giving a mechanism for safe concurrent access to state much like an actor would.</p>
          <p>The advantage of Agents is that they are a bit lighter weight than using actors to encapsulate state. If you see a single stateful value or object that you need to safely handle, you can consider if an Agent might<a id="GBS.0260.02"></a> be a good fit, especially if you're thinking about how to make operations atomic (that is, checking the value, and then setting the value if it meets a certain condition where race conditions would be problematic). Thus, when you need to access a single value from across threads, Agents offer a nice alternative. to Actors.</p>
          <p>Agents are not a core feature in Akka, and so they are in a separate module<a id="GBS.0260.03"></a> that you need to place in your project's <code class="literal">build.sbt</code> file:</p>
          <div class="informalexample">
            <pre class="programlisting">"com.typesafe.akka" %% "akka-agent" % "2.3.6"</pre>
          </div>
          <p>A fairly standard example is a bank account withdrawal where we first need to check to see if there is enough money in the bank account; and then, if there is, we can withdraw the money. Because two threads could check the account, and then deduct the money from the account, we need the account<a id="GBS.0260.04"></a> check-and-set operation to be one atomic operation so that we ensure the value isn't modified after it's read.</p>
          <p>If we used an integer shared across threads, it would be possible to do something like this if two people try to withdraw $20 from an account at the same time:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Account has $25.</li>
              <li class="listitem">Husband and wife try $20 withdrawal simultaneously.</li>
              <li class="listitem">Husband checks to see if account has more than $20. Account<a id="GBS.0260.05"></a> has $25.</li>
              <li class="listitem">Wife checks to see if account has more than $20. Account has $25.</li>
              <li class="listitem">Husband withdraws $20, setting account to $5.</li>
              <li class="listitem">Wife withdraws $20, setting account to $5 (illegal!.).</li>
            </ol>
          </div>
          <p>Because the account had enough money in it when both threads checked the account, both threads proceeded to try to withdraw the money. However, when the second thread deducted the amount, it didn't see that someone else had<a id="GBS.0261.01"></a> already taken the money. The bank has now lost $20 and would not know where it went! The application would generally appear to act normal, but if two transactions happen at the same time, money disappears and nobody notices. If this happened a few hundred thousand times before someone caught the issue, the bank could have potentially lost hundreds of thousands of dollars!</p>
          <p>We need the check and<a id="GBS.0261.02"></a> set operation to be atomic (one complete unit of work) to provide this functionality safely. Doing this with an actor is certainly possible as the actor will only handle one message at a time, but it's a bit more succinct to do this with an agent.</p>
          <p>Agents use actors and<a id="id596" class="indexterm"></a> threads in their underlying implementation, so <a id="id597" class="indexterm"></a>we need to provide an execution context for them. We'll create an actor system<a id="GBS.0261.03"></a> and use its dispatcher to create the agent with the $25 in the account:</p>
          <div class="informalexample">
            <pre class="programlisting">import akka.actor.ActorSystem;
import akka.agent.Agent;

//Java
ActorSystem system = ActorSystem.create();
Agent&lt;Integer&gt; account = Agent.create(25, dispatcher);

//Scala
val system = ActorSystem()
implicit valec = system.dispatcher
val account = Agent(25)</pre>
          </div>
          <p>You can get the value with <code class="literal">Agent.get()</code> or <code class="literal">Agent.apply</code>:</p>
          <div class="informalexample">
            <pre class="programlisting">Integer currentValue<a id="GBS.0261.04"></a> = account.get();
valcurrentValue = account()</pre>
          </div>
          <div title="Note" style="" class="note">
            <div class="inner">
              <h3 class="title"><a id="tip17"></a>Tip</h3>
              <p>Note that getting the value will immediately return the value, although operations may be pending.</p>
            </div>
          </div>
          <p>To update the value with the check-and-set operation, we can provide a function (int =&gt;int) describing the operation using send. For Java, you need to provide a Mapper function:</p>
          <div class="informalexample">
            <pre class="programlisting">//Java
final Integer ammountToWithdraw = 20;
account.send(new akka.dispatch.Mapper&lt;Integ<a id="GBS.0261.05"></a>er, Integer&gt;() {
            public Integer apply(Integer i) {
                if(ammountToWithdraw&lt;= i)
                    return i - ammountToWithdraw;
                else
                    return i;
            }
        });

//Scala
valammountToWithdraw = 20
account.send { i =&gt;
  if(i&gt;= 20) {
i - 20
  } else i
}</pre>
          </div>
          <p>These operations are fire-and-forget, and they run in the other thread pool,<a id="GBS.0262.01"></a> so you would need to complete a future if you want to get the result of the operation back from the agent. The <code class="literal">alter</code> method is identical, except it returns the result of the operation in future.</p>
          <p>Scala offers us <a id="id598" class="indexterm"></a>some extra flexibility to be able to complete this operation. In <a id="id599" class="indexterm"></a>Scala, you can use a transaction block to allow multiple agents to participate in one atomic operation, and return the result<a id="GBS.0262.02"></a> of that block. If we want to move money from one account to another, for example, then the transaction block can be used to have multiple agents interact, as shown in the following code:</p>
          <div class="informalexample">
            <pre class="programlisting">import scala.concurrent.stm._
val wifeAccount = Agent(25)
val husbandAccount = Agent(0)
val wasSuccess = atomic { txn =&gt;
  if(wifeAccount() &gt;= 20) {
wifeAccount.send(_ - 20)
husbandAccount.send(_ + 20)
    true<a id="GBS.0262.03"></a>
  } else false
}</pre>
          </div>
          <p>Agents can be a useful little abstraction to have in your tool belt. Again, think of places you could use <code class="literal">AtomicInteger</code>. Now, you have an <code class="literal">AtomicAnything</code> object and it's called an Agent.</p>
          <p>Documentation for<a id="id600" class="indexterm"></a> Agents can be found here:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li style="list-style-type: disc;" class="listitem">
                <a href="http://doc.akka.io/docs/akka/snapshot/java/agents.html" class="ulink">http://doc.akka.io/docs/akka/snapshot/java/agents.html</a>
              </li>
              <li style="list-style-type: disc;" class="listitem">
                <a href="http://doc.akka.io/docs/akka/snapshot/scala/agents.html" class="ulink">http://doc.akka.io/docs/akka/snapshot/scala/agents.html</a>
              </li>
            </ul>
          </div>
        </div>
        <div title="Akka Persistence" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec97"></a>Akka Persistence</h2>
              </div>
            </div>
          </div>
          <p>Another module<a id="id601" class="indexterm"></a> that<a id="GBS.0262.04"></a> may be of interest is Akka Persistence. Akka Persistence <a id="id602" class="indexterm"></a>gives a mechanism to maintain actor state through crashes/JVM restarts or restarts of the actor by a supervisor.</p>
          <p>It's common to misunderstand the name of the library to mean that it has a mechanism to use external persistence mechanisms such as databases and key-value stores. You would not use Akka persistence to store user information or<a id="GBS.0262.05"></a> account information, for example.</p>
          <p>Remember that, by default, when an actor restarts, it loses any internal state and only keeps its constructor arguments. Akka Persistence offers the ability to add a journal of events that an actor has encountered so that an actor can be run through those events again after restarting to restore its state. By re-applying the journal of events, the actor will fast-forward,<a id="GBS.0263.01"></a> recollecting any internal state. For instance, if you're building a metrics library, an in-memory counter collecting latency information from an endpoint would be able to more accurately collect data by using persistence. If the actor restarted, it would be able to roll forward through events since its last flush, and then pass that information along successfully.</p>
          <p>Note that the<a id="id603" class="indexterm"></a> Akka Persistence<a id="GBS.0263.02"></a> module is marked experimental at the <a id="id604" class="indexterm"></a>time of writing (Akka 2.4 was released GA a couple weeks before the last editing was completed on this book.) Binary compatibility is not guaranteed across minor versions while modules are marked experimental; thus, it should be added to a project with some caution that understands the state of the component. More information is available on Akka Persistence<a id="GBS.0263.03"></a> in the Akka documentation.</p>
        </div>
        <div title="Akka I/O" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec98"></a>Akka I/O</h2>
              </div>
            </div>
          </div>
          <p>Akka I/O <a id="id605" class="indexterm"></a>was introduced in Akka 2.2, which was a joint effort from the Akka and <a id="id606" class="indexterm"></a>Spray teams based on Spray's underlying I/O module. It offers some lower-level TCP and Socket abstractions to build your own network communication. As Akka itself tries to raise the level of abstraction, this book has focused on introducing Akka as a toolkit that takes care of<a id="GBS.0263.04"></a> network communication concerns for you. However, if you want to handle TCP communication yourself, then there are tools in Akka that can help you do so.</p>
          <p>Handling your own TCP communication is a fairly advanced topic and is beyond the scope of this book, but there are some libraries that you can read, such as the Brando Redis client library, that will give some good examples of how to handle TCP<a id="GBS.0263.05"></a> communication using Akka I/O. It can be accessed <a id="id607" class="indexterm"></a>at <a href="https://github.com/chrisdinn/brando" class="ulink">https://github.com/chrisdinn/brando</a>. Redis communication is a good example for analysis as it is quite simple.</p>
        </div>
        <div title="Akka streams and HTTP" class="section">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch09lvl2sec99"></a>Akka streams and HTTP</h2>
              </div>
            </div>
          </div>
          <p>Akka Streams<a id="id608" class="indexterm"></a> have been <a id="id609" class="indexterm"></a>discussed briefly in the chapter on Mailbox-related items. Streams is one of the more interesting new modules in Akka as a reactive streams implementation. Akka HTTP is built on top of<a id="GBS.0264.01"></a> Akka Streams with help from the Spray team.</p>
          <p>Akka Streams and Reactive Streams in general are a more advanced topic. If you would like to explore Akka Streams, I would recommend beginning with learning about Reactive Streams. As Akka HTTP <a id="id610" class="indexterm"></a>is built on Akka Streams, you would likely want to learn about <a id="id611" class="indexterm"></a>Akka Streams before exploring this topic. Akka HTTP, as the name suggests, offers an abstraction<a id="GBS.0264.02"></a> to build HTTP Client or Server applications.</p>
        </div>
      </div>
    </div>
    <div style="display:none;">
      <a id="GBS.0264.03"></a>
    </div>
  </body>
</html>
