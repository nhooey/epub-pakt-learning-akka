<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Multicore architecture as a distribution problem</title><link rel="stylesheet" href="epub.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></meta></head><body id="page"><div style="display:none;"><a id="GBS.0153.01"></a></div><div title="Multicore architecture as a distribution problem" class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"></a>Multicore architecture as a distribution problem</h1></div></div></div><p>Utilizing multiple cores <a id="id359" class="indexterm"></a>in an application can seem like a difficult problem to approach. Traditional thread-based abstractions were very difficult to get right. When threads share access to mutable state, it&#39;s easy to build in race conditions that don&#39;t present themselves until you&#39;ve deployed and are running your app at scale. Tim Sweeny has<a id="GBS.0153.02"></a> said before that, in a concurrent world, imperative is the wrong default. Fortunately, for us today we have different abstractions that we can use to utilize all of those cores available to us, and they&#39;re much easier to build correct concurrent software on than thread abstractions using synchronization and locking.</p><p>It turns out that utilizing multicore architecture can be looked at as a distribution<a id="GBS.0153.03"></a> problem&#8212;we want to take some work and run it somewhere else, either on another CPU or another machine. When working with actors in Akka, the differences between scaling up and scaling out can begin to blur. We can start to ignore the differences between another machine or another core, and instead only think about the problem as sending a message to an actor. We want to send some work somewhere<a id="GBS.0153.04"></a> else to be done, and then, at some point in time, we&#39;ll receive a response to the request. Looking at scaling up is a great way to begin to understand how you might eventually scale out&#8212;if you can do work across 8 cores with Actors, doing work across 8 machines is a small step from there.</p><p>The focus of this chapter is on specifically utilizing multiple cores rather than utilizing multiple machines,<a id="GBS.0153.05"></a> so we&#39;ll highlight the details in that context. The primary mechanism for utilizing multiple cores is parallelism&#8212;our applications must do multiple things at the same time. Essentially, we want to separate work into discrete pieces and run the work in different places at the same time to utilize all of the cores that are available.</p><p>There are two<a id="id360" class="indexterm"></a> abstractions in Akka that you can use to do work<a id="GBS.0154.01"></a> in parallel across cores: Futures and Actors. We&#39;ll look at both of these abstractions in relation to doing heavy computation in parallel at this point. We will still look at how we can better utilize our hardware using both of these abstractions. We&#39;ll also talk about when one might be better to use than the other in this context.</p></div><div style="display:none;"><a id="GBS.0154.02"></a></div></body></html>