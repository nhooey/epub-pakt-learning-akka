<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>One Giant Monolith or Many Micro Services?</title>
    <link rel="stylesheet" href="epub.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2" />
  </head>
  <body id="page">
    <div style="display:none;">
      <a id="GBS.0179.01"></a>
    </div>
    <div title="One Giant Monolith or Many Micro Services?" class="section">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title"><a id="ch06lvl1sec40"></a>One Giant Monolith or Many Micro Services?</h1>
          </div>
        </div>
      </div>
      <p>Since I started slinging code, Martin Fowler has been one of my heroes as a developer; so, when I see him reasoning about a problem I'm also pondering, I take notes.</p>
      <p>If we're talking about microservices <a id="id424" class="indexterm"></a>and distributed systems, he has a few articles on<a id="id425" class="indexterm"></a> his site <a href="http://www.martinfowler.com/" class="ulink">http://www.martinfowler.com/</a>, which you might want to read.</p>
      <p>The first valuable point is that<a id="GBS.0179.02"></a> in the life of an application, while complexity of an application is low, it can be more efficient for a small team to build a single large application—a monolith—as opposed to trying to build networked services. Start by building one application. Once complexity in the application increases, productivity can fall because teams have to do a lot of coordination of activities to get code merged,<a id="GBS.0179.03"></a> and work on features together. At this point, you can start to see productivity benefits of using smaller networked services.</p>
      <p>The second valuable point is that building with a monolith-first approach will enable you to understand where services should be separated when you get around to splitting your services into many smaller applications. Fowler argues that you are quite likely to pick the<a id="GBS.0179.04"></a> wrong services to represent as discreet applications until you've actually been working on your system for a while.</p>
      <p>Once you have some experience and data from running your system in production, it will be clear which pieces will benefit from being separated in terms of both performance and team velocity when adding features. As you start deploying microservices, you can scale up the more loaded<a id="GBS.0179.05"></a> services in an asymmetrical manner so that the most used pieces of the application have their own larger cluster of servers.</p>
      <p>Luckily, Akka can make deployment decisions more of a configuration item rather than code, but having multiple code bases can greatly ease having large teams work on a codebase. It eliminates the problem of Brooks Law (adding more resources to an already late project makes<a id="GBS.0180.01"></a> it later) by eliminating communication channels and isolating code commits to separate repositories (no more merge hell).</p>
      <p>Ultimately, you may want to defer considering building a distributed system until you have a system that is too complex to manage as a monolith, or at least until you have good data-backed justifications (performance or team effort related) for deploying in such a manner.</p>
      <p><a id="GBS.0180.02"></a>Regardless of whether you decide to build a monolith or services out of the gate, you may want to put different concerns into libraries from day one. You can get the benefits of having teams work on different code bases before you're ready to actually deploy separate applications. Once you want to split your application, it will be much easier to manage sharing code if you've done this from the start.</p>
    </div>
    <div style="display:none;">
      <a id="GBS.0180.03"></a>
    </div>
  </body>
</html>
