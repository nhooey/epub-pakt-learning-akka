<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Creating your first Akka application – setting up the SBT project</title><link rel="stylesheet" href="epub.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></meta></head><body id="page"><div style="display:none;"><a id="GBS.0046.01"></a></div><div title="Creating your first Akka application – setting up the SBT project" class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"></a>Creating your first Akka application – setting up the SBT project</h1></div></div></div><p>Now that we have covered <a id="id99" class="indexterm"></a>setting up your environment and how to create a project, we<a id="id100" class="indexterm"></a> can proceed with creating some actor code in Akka, and then look at how to validate that code. We will be using<a id="id101" class="indexterm"></a> <span class="strong"><strong>simple build tool</strong></span>(<span class="strong"><strong>SBT</strong></span>), which is the preferred build tool for Scala projects and is also the build tool that Play Framework and Activator<a id="GBS.0046.02"></a> use under the hood. It&#39;s not complex and we will use it only for managing dependencies and building a testing and running applications, so it should not be an obstacle to learning Akka.</p><div title="Adding Akka to build.sbt" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"></a>Adding Akka to build.sbt</h2></div></div></div><p>We will now open the<a id="id102" class="indexterm"></a> application (either Java or Scala) in our favorite IDE. The<a id="id103" class="indexterm"></a> scaffolding Activator created is not for an Akka project, so we will need to add the Akka dependencies<a id="GBS.0046.03"></a> first. We will add both the Akka core Akka module (akka-actor) and the Akka test-kit, which contains tools to more easily allow us to test the actors.</p><p>In the <code class="literal">build.sbt</code> file, you will see something roughly like this for a Scala project. Note the dependencies are actually Maven dependencies. Any Maven dependencies can easily be added, as we&#39;ll cover shortly. The Java and Scala projects will be more<a id="GBS.0046.04"></a> or less identical; however the Java project will have a Junit dependency instead of Scalatest:</p><div class="informalexample"><pre class="programlisting">name := &quot;&quot;&quot;akkademy-db-java&quot;&quot;&quot;
version := &quot;1.0&quot;
scalaVersion := &quot;2.11.1&quot;
libraryDependencies ++= Seq( &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.6&quot;, &quot;com.typesafe.akka&quot; %% &quot;akka-testkit&quot; % &quot;2.3.6&quot; % &quot;test&quot;, &quot;junit&quot;             % &quot;junit&quot;           % &quot;4.11&quot;  % &quot;test&quot;, &quot;com.novocode&quot;      % &quot;junit-interface&quot;<a id="GBS.0046.05"></a> % &quot;0.10&quot;  % &quot;test&quot; )</pre></div><p>To Include Akka, we need to add a new dependency.</p><p>Your dependencies should look something like this for Java:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq( &quot;com.typesafe.akka&quot; % &quot;akka-actor_2.11&quot; % &quot;2.3.6&quot;, &quot;junit&quot;             % &quot;junit&quot;           % &quot;4.11&quot;  % &quot;test&quot;, &quot;com.novocode&quot;      % &quot;junit-interface&quot; % &quot;0.10&quot;  % &quot;test&quot; )</pre></div><p>And something like this for Scala:</p><div class="informalexample"><pre class="programlisting">name := &quot;&quot;&quot;akkademy-db-scala&quot;&quot;&quot;<a id="GBS.0047.01"></a>
version := &quot;1.0&quot;
scalaVersion := &quot;2.11.1&quot;
libraryDependencies ++= Seq( &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.3&quot;, &quot;com.typesafe.akka&quot; %% &quot;akka-testkit&quot; % &quot;2.3.6&quot; % &quot;test&quot;, &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;2.1.6&quot; % &quot;test&quot;
)</pre></div><div title="A note on getting the right Scala version with %%" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"></a>A note on getting the right Scala version with %%</h3></div></div></div><p>As Scala does not have binary<a id="id104" class="indexterm"></a> compatibility across major versions, libraries will often be built and published across<a id="GBS.0047.02"></a> several versions of Scala. To have SBT try to resolve the dependency built for the correct Scala version for your project, you can change the dependency declared in the <code class="literal">build.sbt</code> file to use two % symbols after the group ID instead of specifying the Scala version in the artifact id.</p><p>For example, in a Scala 2.11 project, these two dependencies are equivalents as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  &quot;com.typesafe.akka&quot;<a id="GBS.0047.03"></a> % &quot;akka-actor_2.11&quot; % &quot;2.3.3&quot;
  &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.3&quot;</pre></div></div><div title="Adding other Dependencies from Maven Central" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"></a>Adding other Dependencies from Maven Central</h3></div></div></div><p>Any Maven <a id="id105" class="indexterm"></a>dependencies can be added here—for <a id="id106" class="indexterm"></a>example from <a href="http://www.mvnrepository.com" class="ulink">http://www.mvnrepository.com</a>. You can see on this link that for any artifact there is an sbt tab that will give you the line to add for the dependency.</p></div></div><div title="Creating your first Actor" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"></a>Creating your first Actor</h2></div></div></div><p>In this section, we will create<a id="GBS.0047.04"></a> an<a id="id107" class="indexterm"></a> actor that receives a message and updates its internal state by storing the values from the message into a map. This is the humble beginnings of our distributed database.</p><div title="Making the Message first" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"></a>Making the Message first</h3></div></div></div><p>We&#39;re going to <a id="id108" class="indexterm"></a>begin our in-memory database with a <code class="literal">SetRequest</code> message that will store a key (String) and a value (any Object) in memory. You can think of it as a combination of both an insert and<a id="GBS.0047.05"></a> an update in one, or like the <code class="literal">set</code> operation on a Map.</p><p>Remember, our actor has to get the message from his mailbox and check what the instruction is in that message. We use the class/type of the message to determine what the instruction is. The contents of that message type describe the exact details of how to fulfill the contract of the API; in this case we will describe the key as a String and<a id="GBS.0048.01"></a> the value as an Object inside the message so that we know what to store.</p><p>Messages should always be immutable in order to avoid strange and unexpected behavior, primarily by ensuring you and your team don&#39;t do unsafe things across execution contexts/threads. Remember also that these messages may not be simply destined for a local actor but for so another machine. If possible, mark everything <code class="literal">val</code><a id="GBS.0048.02"></a> (Scala) or <code class="literal">final</code> (Java) and use immutable collections and types such as those found in Google Guava (Java) or the Scala Standard Library.</p><div title="Java" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec04"></a>Java</h4></div></div></div><p>Here is our Set message <a id="id109" class="indexterm"></a>in Java as an immutable object. This is a fairly standard approach to immutable objects in Java. It will be a familiar sight to any skilled Java developer; you should generally prefer immutability in all of your code.</p><div class="informalexample"><pre class="programlisting">package com.akkademy.message<a id="GBS.0048.03"></a>s;
public class SetRequest { private final String key; private final Object value;public Set(String key, Object value) { 
 this.key = key;
 this.value = value;
 }
    public String getKey() { return key; }    public Object getValue() { return value;
    }
}</pre></div></div><div title="Scala" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec05"></a>Scala</h4></div></div></div><p>In Scala we have a much more succinct way of<a id="id110" class="indexterm"></a> defining immutable messages&#8212;the case class. The case class lets us create an immutable<a id="GBS.0048.04"></a> message; values can only be set once in the constructor and then are read from the fields:</p><div class="informalexample"><pre class="programlisting">package com.akkademy.messages case class SetRequest(key: String, value: Object)</pre></div><p>That&#39;s it for the messages.</p></div></div><div title="Defining Actor response to the Message" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"></a>Defining Actor response to the Message</h3></div></div></div><p>Now that we have<a id="id111" class="indexterm"></a> the message created, we can create the actor and describe the behavior that the actor will take in response to our message. In our very early<a id="GBS.0048.05"></a> example here, we are going to do two things:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log the message.</li><li class="listitem">Store the contents of any Set message for later retrieval.</li></ol></div><p>We will build on the example in future chapters to let us retrieve stored messages so that this actor can be used as a thread-safe caching abstraction (and eventually a full-on distributed key-value store).</p><p>We&#39;ll have a look at the Java8 actor first.</p><div title="Java – AkkademyDb.java" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec06"></a>Java – AkkademyDb.java</h4></div></div></div><p><a id="GBS.0049.01"></a>The following <a id="id112" class="indexterm"></a>code denotes Actor response to the message in Java:</p><div class="informalexample"><pre class="programlisting">package com.akkademy;
import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import akka.japi.pf.ReceiveBuilder;
import com.akkademy.message.SetRequest;
import java.util.HashMap;
import java.util.Map;
public class AkkademyDb extends AbstractActor { protected final LoggingAdapter log = Logging.getLogger(context<a id="GBS.0049.02"></a>().system(), this); protected final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); 
    private AkkademyDb(){ receive(ReceiveBuilder.match(SetRequest.class, message -&gt; { log.info(&quot;Received set request &#8211; key: {} value: {}&quot;, message.getKey(), message.getValue()); map.put(message.getKey(), message.getValue()); }).matchAny(o -&gt; log.info(&quot;received unknown message {}&quot;, o)).build()
      <a id="GBS.0049.03"></a>  );
    }
}</pre></div><p>The actor is a Java class that extends <code class="literal">AbstractActor</code> (a Java8 Akka Actor API). We create the logger and the map in the class as protected members so we can access them in test cases later in the chapter.</p><p>In the constructor we call receive. The receive method takes a <code class="literal">ReceiveBuilder</code> which has several methods that we call chained together to produce the final <code class="literal">ReceiveBuilder</code>. With this,<a id="GBS.0049.04"></a> we describe how the actor should behave in response to different message types. We define two behaviors here and we will look at them one at a time.</p><p>First, we define the behavior to respond to any <code class="literal">SetRequest</code> messages with:</p><div class="informalexample"><pre class="programlisting">match(SetRequest.class, message -&gt; { log.info(&quot;Received Set request: {}&quot;, message); map.put(message.getKey(), message.getValue()); }).</pre></div><p>The <code class="literal">ReceiveBuilder</code> match method in the<a id="GBS.0049.05"></a> Java8 API is somewhat similar to a case statement except that we can match on class types. More formally, this is pattern matching.</p><p>The match method call, then, says: if the message is of type <code class="literal">SetRequest.class</code>, take that message, log it, and put a new record in the map using the key and value of that Set message.</p><p>Second, we define a<a id="id113" class="indexterm"></a> catch-all to simply log any unknown message.</p><div class="informalexample"><pre class="programlisting">matchAny(o -&gt; log.info(&quot;received<a id="GBS.0050.01"></a> unknown message&quot;))</pre></div></div><div title="Scala – AkkademyDb.scala" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec07"></a>Scala – AkkademyDb.scala</h4></div></div></div><p>Scala is a natural <a id="id114" class="indexterm"></a>fit as the language has pattern matching as a first-class language construct. We&#39;ll have a look at the Scala equivalent code now:</p><div class="informalexample"><pre class="programlisting">package com.akkademy
import akka.actor.Actor
import akka.event.Logging
import scala.collection.mutable.HashMap
import com.akkademy.messages.SetRequest
class AkkademyDb extends Actor {
  val map = new<a id="GBS.0050.02"></a> HashMap[String, Object]
  val log = Logging(context.system, this) override def receive = { case SetRequest(key, value) =&gt; { log.info(&quot;received SetRequest - key: {} value: {}&quot;, key, value) map.put(key, value) } case o =&gt; log.info(&quot;received unknown message: {}&quot;, o);
  }
}</pre></div><p>In the Scala API, we mix in the Actor trait, define the map and logger as we did in Java, and then implement the receive method.<a id="GBS.0050.03"></a> The receive method on the Actor super-type returns the Receive which, in the Akka source, is defined as a partial function as follows:</p><div class="informalexample"><pre class="programlisting">type Receive = scala.PartialFunction[scala.Any, scala.Unit]</pre></div><p>We define the behavior for the response to the <code class="literal">SetRequest</code> message using pattern matching to produce the partial function. We can extract the key and the value variables for clearer code using pattern matching<a id="GBS.0050.04"></a> semantics:</p><div class="informalexample"><pre class="programlisting">case SetRequest(key, value)</pre></div><p>The behavior is to simply log the request, and then to set the key/value in the map.</p><div class="informalexample"><pre class="programlisting">    case SetRequest(key, value) =&gt; { log.info(&quot;received SetRequest - key: {} value: {}&quot;, key, value)
      map.put(key, value)
    }</pre></div><p>Finally, we add a <a id="id115" class="indexterm"></a>catch-all case to simply log unknown messages:</p><div class="informalexample"><pre class="programlisting">    case o =&gt; log.info(&quot;received unknown message: {}&quot;, o);</pre></div><p>That&#39;s it for the<a id="GBS.0050.05"></a> actor. Now we have to validate we did everything correctly.</p></div></div></div><div title="Validating the code with unit tests" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"></a>Validating the code with unit tests</h2></div></div></div><p>While books<a id="id116" class="indexterm"></a> covering frameworks may print to the console or create <a id="id117" class="indexterm"></a>web pages that are suitable evidence that our code is working, we&#39;re going to be using unit tests to validate code and to demonstrate its use. Library code and services often don&#39;t have an API that is easy to interact with or to<a id="GBS.0051.01"></a> otherwise to observe, testing is generally how these components are validated in almost every project. This is an important skill for any serious developer to have under their belt.</p><div title="Akka Testkit" class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"></a>Akka Testkit</h3></div></div></div><p>Akka provides a<a id="id118" class="indexterm"></a> test kit that provides almost anything you would ever need to test your actor code. We included the test kit dependencies earlier when we set up our project. For reference, the SBT dependency<a id="GBS.0051.02"></a> to place in <code class="literal">build.sbt </code>is as follows:</p><div class="informalexample"><pre class="programlisting">  &quot;com.typesafe.akka&quot; %% &quot;akka-testkit&quot; % &quot;2.3.6&quot; % &quot;test&quot;</pre></div><p>We&#39;re going to use the <code class="literal">TestActorRef</code> generic here from the testkit instead of a normal <code class="literal">ActorRef</code> (which we will look at in the next chapter). The <code class="literal">TestActorRef</code> does two things: it makes the actor&#39;s API synchronous so we don&#39;t need to think about concurrency in our tests, and it gives us access to the underlying<a id="GBS.0051.03"></a> Actor object.</p><p>To be clear, Akka hides the actual Actor (<code class="literal">AkkademyDb</code>) and instead gives a reference to the actor that you send messages to. This encapsulates the actor to enforce message passing as nobody can access the actual object instance.</p><p>Next we will look at the source code, and then explain it line by line.</p><div title="Java" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec08"></a>Java</h4></div></div></div><p>This is the source code<a id="id119" class="indexterm"></a> for Akka toolkit:</p><div class="informalexample"><pre class="programlisting">package com.akkademy;
import static<a id="GBS.0051.04"></a> org.junit.Assert.assertEquals;
import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.testkit.TestActorRef;
import com.akkademy.messages.SetRequest;
import org.junit.Test;
public class AkkademyDbTest { ActorSystem system = ActorSystem.create(); 
    @Test
    public void itShouldPlaceKeyValueFromSetMessageIntoMap() { TestActorRef&lt;AkkademyDb&gt; actorRef = TestActorRef.create(<a id="GBS.0051.05"></a>system, Props.create(AkkademyDb.class)); actorRef.tell(new SetRequest(&quot;key&quot;, &quot;value&quot;),ActorRef.noSender());
        AkkademyDb akkademyDb = actorRef.underlyingActor(); assertEquals(akkademyDb.map.get(&quot;key&quot;), &quot;value&quot;);}
}</pre></div></div><div title="Scala" class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec09"></a>Scala</h4></div></div></div><p>The following source code represents<a id="id120" class="indexterm"></a> interaction with the actor:</p><div class="informalexample"><pre class="programlisting">package com.akkademy
import akka.util.Timeout
import org.scalatest.{BeforeAndAfterEach, FunSpecLike, Matchers}<a id="GBS.0052.01"></a>
import akka.actor.ActorSystem
import com.akkademy.messages.SetRequest
import akka.testkit.TestActorRef
import scala.concurrent.duration. class AkkademyDbSpec extends FunSpecLike with Matchers with BeforeAndAfterEach {implicit val system = ActorSystem()
  describe(&quot;akkademyDb&quot;) { describe(&quot;given SetRequest&quot;){ it(&quot;should place key/value into map&quot;){ val actorRef = TestActorRef(new AkkademyDb)<a id="GBS.0052.02"></a> actorRef ! SetRequest(&quot;key&quot;, &quot;value&quot;)
        val akkademyDb = actorRef.underlyingActorakkademyDb.map.get(&quot;key&quot;) should equal(Some(&quot;value&quot;))
      }
    }
  }
}</pre></div><p>This is the first time we are looking at interacting with an actor so there is some new code and behavior, some of it is test-specific and some related to interacting with the actor.</p><p>We&#39;ve described an Actor System as a place where actors<a id="GBS.0052.03"></a> and their addresses reside, the first thing we need to do before creating the actor is to get a reference to an actor system. We create one as a field in the test:</p><div class="informalexample"><pre class="programlisting">//Java
ActorSystem system = ActorSystem.create();
//Scala
implicit val system = ActorSystem()</pre></div><p>After creating the actor system, we can now create our actor in the actor system. As mentioned, we&#39;re going to use Akka Testkit to create a <code class="literal"><a id="GBS.0052.04"></a>TestActorRef</code> which has a synchronous API, and lets us get at the underlying actor. We create the actor in our actor system here:</p><div class="informalexample"><pre class="programlisting">//Java
TestActorRef&lt;AkkademyDb&gt; actorRef = TestActorRef.create(system, Props.create(AkkademyDb.class));
//Scala
val actorRef = TestActorRef(new AkkademyDb)</pre></div><p>We call the Akka Testkit <code class="literal">TestActorRef</code> create method, passing in the actor system we created (it is implicitly passed<a id="GBS.0052.05"></a> in Scala) and a reference to the class. We will look at actor creation in further chapters. Actor instances are hidden away so the act of creating an actor in our actor system returns an <code class="literal">ActorRef</code> (in this case, a <code class="literal">TestActorRef</code>) that we can send messages to. The system and class reference is enough for Akka to create this simple actor in our actor system so we have successfully created our first<a id="GBS.0053.01"></a> actor.</p><p>We communicate with an actor via message-passing. We place a message into an actor&#39;s mailbox with &#39;tell&#39; or &#39;!&#39; in Scala, which is still read as &#39;tell&#39;. We define that there is nobody to respond to for this message as a parameter of the <code class="literal">tell</code> method in Java. In Scala, outside of an actor, this is implicit.</p><div class="informalexample"><pre class="programlisting">//Java
actorRef.tell(new SetRequest(&quot;key&quot;, &quot;value&quot;), ActorRef.noSender());
//Scala<a id="GBS.0053.02"></a>
actorRef ! SetRequest(&quot;key&quot;, &quot;value&quot;)</pre></div><p>Because we are using <code class="literal">TestActorRef</code>, the call to tell will not continue until the request is processed. This is fine for a look at our first actor but it&#39;s important to note that this example does not expose the asynchronous nature of the Actor&#39;s API. This is not the usual behavior; tell is an asynchronous operation that returns immediately in normal usage.</p><p><a id="GBS.0053.03"></a>Finally, we need to ensure that the behavior is correct by asserting that the actor placed the value into its map. To do this, we get the reference to the underlying Actor instance, and inspect the map by calling <code class="literal">get(&quot;key&quot;)</code> and ensuring the value is there.</p><div class="informalexample"><pre class="programlisting">//Java
AkkademyDb akkademyDb = actorRef.underlyingActor();
assertEquals(akkademyDb.map.get(&quot;key&quot;), &quot;value&quot;);
//Scala
val akkademyDb = actorRef.underlyingActor<a id="GBS.0053.04"></a>
akkademyDb.map.get(&quot;key&quot;) should equal(Some(&quot;value&quot;))</pre></div><p>That&#39;s it for the creation <a id="id121" class="indexterm"></a>of our first simple test case. This basic pattern can be built on for unit testing Actors synchronously. As we go through the book, we will look at more extensive unit-testing examples as well as asynchronous integration testing of our actors.</p></div></div></div><div title="Running the test" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"></a>Running the test</h2></div></div></div><p>We&#39;re almost there! Now that we&#39;ve built our <a id="id122" class="indexterm"></a>tests,<a id="GBS.0053.05"></a> we can go to the command line and run &#39;activator&#39; to start the activator cli. Next we can run &#39;clean&#39; to tidy up any garbage and then &#39;test&#39; which will fire off the tests. To do this in one step, we can run activator clean test.</p><p>You should see something like the following for the Java Junit test:</p><div class="informalexample"><pre class="programlisting">[INFO] [01/12/2015 23:09:24.893] [pool-7-thread-1] [akka://default/user/$$a] Received Set request:<a id="GBS.0054.01"></a> Set{key=&#39;key&#39;, value=value}
[info] Passed: Total 1, Failed 0, Errors 0, Passed 1
<span class="strong"><strong>[</strong></span>success] Total time: 7 s, completed 12-Jan-2015 11:09:25 PM</pre></div><p>And if you&#39;re using Scala, then scala-test will give you a bit nicer output:</p><div class="informalexample"><pre class="programlisting">[info] AkkademyDbSpec:
[info] akkademyDb
[info] - should place key/value from Set message into map
[info] Run completed in 1 second, 990 milliseconds.
[info] Total number of tests<a id="GBS.0054.02"></a> run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.</pre></div><p>The output will tell you some information about how many tests were run, how many tests failed, and, if there are any errors, it will indicate where the failures occurred so that you can investigate. Once you have a test in place on a behavior, you can be<a id="GBS.0054.03"></a> confident that any changes or refactorings you apply did not break the behavior.</p></div></div><div style="display:none;"><a id="GBS.0054.04"></a></div></body></html>